
import "common_cells.anvil"

chan slave_ch<w_chan_t : type, 
              aw_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type, 
              select_t : type> 
{
    left slv_req_aw : (aw_chan_t@#1),
    left slv_req_w  : (w_chan_t@#1),
    right slv_res_b : (b_chan_t@#1),
    left slv_req_ar : (ar_chan_t@#1),
    right slv_res_r : (r_chan_t@#1),
    left slv_w_select : (select_t@#1),
    left slv_r_select : (select_t@#1)
}
chan master_ch<aw_chan_t : type, 
              w_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type> {
    right mst_aw_req : (aw_chan_t@#1),
    right mst_w_req  : (w_chan_t@#1),
    left mst_b_resp  : (b_chan_t@#1),
    right mst_ar_req : (ar_chan_t@#1),
    right mst_r_resp : (r_chan_t@#1)
}

proc axi_demux<aw_chan_t : type, 
              w_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type, 
              select_t : type
              NoMstPorts : int>
(
    slv_ep: left slave_ch<w_chan_t, aw_chan_t, b_chan_t, ar_chan_t, r_chan_t, select_t>,
    mst_ep_0: right master_ch<aw_chan_t, w_chan_t, b_chan_t, ar_chan_t, r_chan_t>,
    mst_ep_1: right master_ch<aw_chan_t, w_chan_t, b_chan_t, ar_chan_t, r_chan_t>
)
// Write Translaction and read trannsaction to be implemented seperately (in different loops for now)
{
    chan aw_sr_le -- aw_sr_ri : spill_ch<aw_chan_t>;
    chan w_sr_le -- w_sr_ri : spill_ch<w_chan_t>;
    chan b_sr_le -- b_sr_ri : spill_ch<b_chan_t>;
    chan ar_sr_le -- ar_sr_ri : spill_ch<ar_chan_t>;
    chan r_sr_le -- r_sr_ri : spill_ch<r_chan_t>;
    chan select_aw_le -- select_aw_ri : spill_ch<select_t>;
    chan select_r_le -- select_r_ri : spill_ch<select_t>;

/* The write transaction is simple as follows:
Loop 1. The slave sends a aw request, we accept it if the spill register is ready to accept a request.
    - Then the req is forwarded to the spill register

Loop 2. The AW transaction is done if the w_fifo is not full
    - If the w_fifo is full, we wait until it is not full before proceeding.
   - If the w_fifo is not full, we get a valid aw request from the spill register.
   - we match the select value to determine which master to send the request to.
    - The master processes the request
    - After master process accepts the request, we ask the spill register to immediately drain the value
    - we push the selected master id into the w_fifo

Loop 3. The Write data transaction bypass from slave
Loop4. The w data is sent to the fifo if the w_fifo is not empty and the read response is not full
    - If the w_fifo is empty, we wait until it is not empty before proceeding.
    - If the b_fifo is full, we wait until it is not full before proceeding.
    - We pop the w_fifo to get the master id we get the w request (as res) from the spill register.
    - Then we send the w request to the selected master , upon completion of this handshake, we ask the spill register to drain the value.

Loop 5. The b channel bypass transaction:
    - we get the master id from the b_fifo
    - We match the master id to get the b response from the selected master.
    - We send the b response to the spill register.

Loop 6. The spill register sends the b response to the slave, upon handshake we drain the value
*/

    loop{//AW slv req bypass
        try _ = recv aw_sr_le.rdy{
            let aw_req = recv slv_ep.slv_req_aw >>
            send aw_sr_le.req(aw_req)//To Do: add syncpattern as anytime immmediately after a message
        } >>
        cycle 1
    }


    loop{ //AW Channel Transaction To Do: add parametrized register by passing
    /*1.*/  try _ = recv w_fifo_ep.full{
                cycle 1
            }
            else{
                  let aw_req = recv aw_sr_le.res >> //sync pattern to say ready to recieve immediately
                  send w_fifo_ep.push(aw_req.select) >>
                  match aw_req.select{
                    0 => {
                            send mst_ep_0.mst_aw_req(aw_req.data) >>
                            send aw_sr_le.drain(1'd1) //
                    }
                    1 => {
                            send mst_ep_1.mst_aw_req(aw_req.data) >>
                            send aw_sr_le.drain(1'd1) //sync pattern to say ready to accept after previous drain
                    }
                    _ => {
                            // can keep doing the match
                            ()
                        }
                  }>> cycle 1
                }
            }
        }

        // Write Channel Transaction

        loop{//W slv req bypass
            try _ = recv w_sr_le.rdy{
                let w_req = recv slv_ep.slv_req_w >>
                send w_sr_le.req(w_req)//To Do: add syncpattern as anytime immmediately after a message
            } >>
            cycle 1
        }
        
        loop{ // The FSM that controls the w channel transaction
            try _ = recv w_fifo_ep.empty {
                cycle 1
            }
            else {
                try _ = recv b_fifo_ep.full {
                    cycle 1
                }
                else { 
                    let w_mst = recv w_fifo_ep.pop >>
                    send b_fifo_ep.push(w_mst) >>
                    match w_mst{
                        0 =>{
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_0.mst_w_req(w_req) >>
                            send w_sr_le.drain(1'd1)
                        }
                        1 => {
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_1.mst_w_req(w_req) >>
                            send w_sr_le.drain(1'd1)
                        }
                        _ => {
                            // can keep doing the match
                            ()
                        }
                    } >>
                    cycle 1
                }
            }
        }
// B channel Transaction
    
    loop{// Master to bypass the value to spill register
        try _ = recv b_fifo_ep.empty {
            cycle 1
        }
        else {
            try _ = recv b_sr_le.rdy {
                let b_mst = recv b_fifo_ep.pop >>
                match b_mst {
                    0 => {
                        let b = recv mst_ep_0.mst_b_resp >>
                        send b_sr_le.req(b)
                    }
                    1 => {
                        let b = recv mst_ep_1.mst_b_resp >>
                        send b_sr_le.req(b)
                    }
                    _ => {
                        // can keep doing the match
                        ()
                    }
            } >>
            cycle 1
        }
    }

    loop {
        // slave gets the b response (spill register bypass)
        let b_resp = recv b_sr_le.res >>
        send slv_ep.slv_res_b(b_resp) >>
        send b_sr_le.drain(1'd1) >> //sync pattern to say ready to drain the value
        cycle 1
    }

}
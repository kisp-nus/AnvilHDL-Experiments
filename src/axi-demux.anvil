
import "common_cells.anvil"

chan slave_ch<w_chan_t : type, 
              aw_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type, 
              select_t : type> 
{
    left slv_req_aw : (aw_chan_t@#1),
    left slv_req_w  : (w_chan_t@#1),
    right slv_res_b : (b_chan_t@#1),
    left slv_req_ar : (ar_chan_t@#1),
    right slv_res_r : (r_chan_t@#1),
    left slv_w_select : (select_t@#1),
    left slv_r_select : (select_t@#1)
}
chan master_ch<aw_chan_t : type, 
              w_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type> {
    right mst_aw_req : (aw_chan_t@#1),
    right mst_w_req  : (w_chan_t@#1),
    left mst_b_resp  : (b_chan_t@#1),
    right mst_ar_req : (ar_chan_t@#1),
    right mst_r_resp : (r_chan_t@#1)
}

proc axi_demux<aw_chan_t : type, 
              w_chan_t : type, 
              b_chan_t : type, 
              ar_chan_t : type, 
              r_chan_t : type, 
              select_t : type
              NoMstPorts : int>
(
    slv_ep: left slave_ch<w_chan_t, aw_chan_t, b_chan_t, ar_chan_t, r_chan_t, select_t>,
    mst_ep_0: right master_ch<aw_chan_t, w_chan_t, b_chan_t, ar_chan_t, r_chan_t>,
    mst_ep_1: right master_ch<aw_chan_t, w_chan_t, b_chan_t, ar_chan_t, r_chan_t>
)
// Write Translaction and read trannsaction to be implemented seperately (in different loops for now)
{
    chan aw_sr_le -- aw_sr_ri : spill_ch<aw_chan_t>;
    chan w_sr_le -- w_sr_ri : spill_ch<w_chan_t>;
    chan b_sr_le -- b_sr_ri : spill_ch<b_chan_t>;
    chan ar_sr_le -- ar_sr_ri : spill_ch<ar_chan_t>;
    chan r_sr_le -- r_sr_ri : spill_ch<r_chan_t>;
    chan select_aw_le -- select_aw_ri : spill_ch<select_t>;
    chan select_r_le -- select_r_ri : spill_ch<select_t>;
    reg aw_in : aw_chan_t;


    // Write Transaction'
        // First we receive the write address
        // and then we send the write address to the selected master
        // Then we forward the acknowledgement back to the master without any delay (ready )
        // Now we are ready for another address write transaction >?
        // Ok there is a fifo of write requests, if that is not full, we can accept another write address
        // If the master for this is not ready, we need to lock the address write channel so it doesnt get overwritten
        // So in general address write channel is unlocked, however when there is a slave request and the master is not ready, 
        // we need to lock the address write channel until the master is ready
        // So the program for write transaction is somewhat like this
        // 1. Receive the write transaction request if the write buffer is not full 
        // 2. Push the request in the write buffer
        // 3. if the master is ready send back the acknowledgement to the axi slave
        // 4. Else lock the aw channel untill this requst can be served
        // 5. If the master is ready unlock this channel ready to accept new address write transaction request



// Corresponding W channel transaction
        // 1. It seems like we can store the order of the write requests in a fifo
        // 2. If the fifo is not empty and the write response fifo is not full
        // 3. we can recv a valid w request from the slave and send it to the selected master (from fifo)
        // 4. If the selected master is ready to accept this transaction we let know the slave


        // Corresponding B channel transaction
        // TBC: When not feeling sleepy

// For aw_channel Anvil Implementation: 
   //  1. We see if the w_fifo is full ? if not we can accept a new write address request
   //  2a. If the selected master is ready to accept this transaction we let know the slave that we are ready to accept the w request
        // Thereby not needing to register this value
   // 2b. Else we register the aw request and wait for the master to be ready
   //3. We send the acknowlegeemnt to the slave that we are ready to accept the write request
   // This completes the aw channel transaction. Therefore we can keep recieving aw requests untill the fifo is full and each aw_req is ack

/* For W_channel:
1a. check if the w_fifo is empty, if its empty do nothing
1b.a If the w_fifo is not empty, check if the b_fifo is full, if its full do nothing
1b.b. If the b_fifo is not full, we can pop a w request from the fifo
2. wait for the w data request from the slave and then send it to the selected master
// Does slave need to keep it constant till it recvs ready or for one cycle ? Ans : it is bypassed through the spill register
In that case a better way to do this is actually abstract the spill register as a component with parametrized bypass that returns the response as soon
as there is one to return (based on that parameter)

So it would be like this

loop1 :  Handles the slave aw channel requests bypass
loop2 : The FSM that controls the aw channel transaction
loop3 : Handles the slave w channel requests bypass
loop4 : The FSM that controls the w channel transaction
    
*/


    loop{//AW slv req bypass
        let _ = recv aw_sr_le.rdy >>
        send slv_ep.aw_ready(1'd1) >>
        let aw_req = recv slv_ep.slv_req_aw >>
        send aw_sr_le.req(aw_req) >>
        cycle 1
    }


    loop{ //AW Channel Transaction To Do: add parametrized register by passing
    /*1.*/  try _ = recv w_fifo_ep.full{
                cycle 1
            }
            else{
                try _ = recv aw_sr_le.rdy {
                    send w_fifo_ep.push(aw_req.select) >>
                    match aw_req.select{
                        0 => {
            /*2.a*/       let _ = recv mst_ep_0.aw_ready >>
                            send aw_sr_le.rdy_in(1'd1) >>
                            let aw_req = recv aw_sr_le.res >>
                            send mst_ep_0.mst_aw_req(*aw_in)
                        } 
                        1 => {
                /*2.a*/    let _ = recv mst_ep_1.aw_ready >>
                            send aw_sr_le.rdy_in(1'd1) >>
                            let aw_req = recv aw_sr_le.res >>
                            send mst_ep_1.mst_aw_req(*aw_in)
                        }
                        _ => {
                            // can keep doing the match
                            ()
                        }
                    }>> cycle 1
                }
                else {
                    cycle 1
                }
            }
        }

        // Write Channel Transaction

        loop{ // W slv req bypass
            let _ = recv w_sr_le.rdy >>
            send slv_ep.w_ready(1'd1) >>
            let w_req = recv slv_ep.slv_req_w >>
            send w_sr_le.req(w_req) >>
            cycle 1
        }
        
        loop{ // The FSM that controls the w channel transaction
            try _ = recv w_fifo_ep.empty {
                cycle 1
            }
            else {
                try _ = recv b_fifo_ep.full {
                    cycle 1
                }
                else { 
                    let w_mst = recv w_fifo_ep.pop >>
                    send b_fifo_ep.push(w_mst) >>
                    match w_mst{
                        0 =>{
                            let _ = recv mst_ep_0.w_ready >>
                            send w_sr_le.rdy_in(1'd1) >>
                            let _ = recv w_sr_le.rdy >>
                            let w_req = w_sr_le.res >>
                            send mst_ep_0.mst_w_req(w_req)
                        }
                        1 => {
                            let _ = recv mst_ep_1.w_ready >>
                            send w_sr_le.rdy_in(1'd1) >>
                            let _ = recv w_sr_le.rdy >>
                            let w_req = w_sr_le.res >>
                            send mst_ep_1.mst_w_req(w_req)
                        }
                        _ => {
                            // can keep doing the match
                            ()
                        }
                    } >>
                    cycle 1
                }
            }
        }
// B channel Transaction
    loop{// Master to slave
        try _ = recv b_fifo_ep.empty {
            cycle 1
        }
        else {
            let b_mst = recv b_fifo_ep.pop >>
            match b_mst {
                0 => {
                    let _ = recv b_sr_le.rdy >>
                    let b_resp = recv mst_ep_0.b_resp >>
                    send b_sr_le.req(b_resp)
                }
                1 => {
                    let _ = recv b_sr_le.rdy >>
                    let b_resp = recv mst_ep_1.b_resp >>
                    send b_sr_le.req(b_resp)
                }
                _ => {
                    // can keep doing the match
                    ()
                }
            } >>
            cycle 1
        }
    }

    loop {
        // slave gets the b response (spill register bypass)
        let _ = recv slv_ep.b_ready >>
        send b_sr_le.rdy_in(1'd1) >>
        let b_resp = recv b_sr_le.res >>
        send slv_ep.b_resp(b_resp) >>
        cycle 1
    }


}

import "common_cells.anvilh"


proc axi_demux<
              T : type,
              A : type,
              select_t : int,
              AW_BYPASS : int,
              W_BYPASS : int,
              B_BYPASS : int,
              AR_BYPASS : int,
              R_BYPASS : int,
              NoMstPorts : int>
(
    slv_ep: left slave_ch<T, A, select_t>,
    mst_ep_0: right master_ch<T, A>,
    mst_ep_1: right master_ch<T, A>
)
// Write Translaction and read trannsaction to be implemented seperately (in different loops for now)
{
// Spill registers for the channels
    
    chan aw_sr_le -- aw_sr_ri : spill_ch<aw_pack<A, select_t> >;
    chan w_sr_le -- w_sr_ri : spill_ch<w_pack<T, select_t> >;
    chan b_sr_le -- b_sr_ri : spill_ch<b_pack>;
    chan ar_sr_le -- ar_sr_ri : spill_ch<ar_pack<A, select_t> >;
    chan r_sr_le -- r_sr_ri : spill_ch<r_pack<T> >;
    spawn spill_reg<aw_pack<A, select_t> , AW_BYPASS>(aw_sr_ri);
    spawn spill_reg<w_pack<T, select_t> , W_BYPASS>(w_sr_ri);
    spawn spill_reg<b_pack, B_BYPASS>(b_sr_ri);
    spawn spill_reg<ar_pack<A, select_t>, AR_BYPASS>(ar_sr_ri);
    spawn spill_reg<r_pack<T>, R_BYPASS>(r_sr_ri);


//---------------------------------------------Write Transaction------------------------------------------------------------
    loop{//AW slv req bypass
        try _ = recv aw_sr_le.rdy{
            let aw_req = recv slv_ep.slv_req_aw >>
            send aw_sr_le.req(aw_req)//To Do: add syncpattern as anytime immmediately after a message
        } >>
        cycle 1
    }


    loop{ //AW Channel Transaction To Do: add parametrized register by passing
    /*1.*/  try _ = recv w_fifo_ep.full{
                cycle 1
            }
            else{
                  let aw_req = recv aw_sr_le.res >> //sync pattern to say ready to recieve immediately
                  send w_fifo_ep.push(aw_req.select) >>
                  match aw_req.select{
                    0 => {
                            send mst_ep_0.mst_aw_req(aw_req.data) >>
                            send aw_sr_le.spill(1'd1) //
                    },
                    1 => {
                            send mst_ep_1.mst_aw_req(aw_req.data) >>
                            send aw_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                    },
                    _ => {
                            // can keep doing the match
                            ()
                        }
                  }>> cycle 1
            }
        }

        // W Channel Transaction

        loop{//W slv req bypass
            try _ = recv w_sr_le.rdy{
                let w_req = recv slv_ep.slv_req_w >>
                send w_sr_le.req(w_req)//To Do: add syncpattern as anytime immmediately after a message
            } >>
            cycle 1
        }
        
        loop{ // The FSM that controls the w channel transaction
            try _ = recv w_fifo_ep.empty {
                cycle 1
            }
            else {
                try _ = recv b_fifo_ep.full {
                    cycle 1
                }
                else { 
                    let w_mst = recv w_fifo_ep.pop >>
                    send b_fifo_ep.push(w_mst) >>
                    match w_mst{
                        0 =>{
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_0.mst_w_req(w_req) >>
                            send w_sr_le.spill(1'd1)
                        },
                        1 => {
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_1.mst_w_req(w_req) >>
                            send w_sr_le.spill(1'd1)
                        },
                        _ => {
                            // can keep doing the match
                            ()
                        }
                    } >>
                    cycle 1
                }
            }
        }
// B channel Transaction
    
    loop{// Master to bypass the value to spill register
        try _ = recv b_fifo_ep.empty {
            cycle 1
        }
        else {
            try _ = recv b_sr_le.rdy {
                let b_mst = recv b_fifo_ep.pop >>
                match b_mst {
                    0 => {
                        let b = recv mst_ep_0.mst_b_resp >>
                        send b_sr_le.req(b)
                    },
                    1 => {
                        let b = recv mst_ep_1.mst_b_resp >>
                        send b_sr_le.req(b)
                    },
                    _ => {
                        // can keep doing the match
                        ()
                    }
                }
            } >>
            cycle 1
        }
    }

    loop {
        // slave gets the b response (spill register bypass)
        let b_resp = recv b_sr_le.res >>
        send slv_ep.slv_res_b(b_resp) >>
        send b_sr_le.spill(1'd1) >> //sync pattern to say ready to spill the value
        cycle 1
    }
// ----------------------------------------------Read Transaction------------------------------------------------------------

    loop{//AR slv req bypass
        try _ = recv ar_sr_le.rdy{
            let ar_req = recv slv_ep.slv_req_ar >>
            send ar_sr_le.req(ar_req)//To Do: add syncpattern as anytime immmediately after a message
        } >>
        cycle 1
    }

    loop{ //AR Channel Transaction To Do: add parametrized register by passing
    /*1.*/  try _ = recv r_fifo_ep.full{
                cycle 1
            }
            else{
                  let ar_req = recv ar_sr_le.res >> //sync pattern to say ready to recieve immediately
                  send r_fifo_ep.push(ar_req.select) >>
                  match ar_req.select{
                    0 => {
                            send mst_ep_0.mst_ar_req(ar_req.data) >>
                            send ar_sr_le.spill(1'd1) //
                    },
                    1 => {
                            send mst_ep_1.mst_ar_req(ar_req.data) >>
                            send ar_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                    },
                    _ => {
                            // can keep doing the match
                            ()
                        }
                  }>> cycle 1
            }
     }

    // R Data Transaction
    loop{    
        try _ = recv r_fifo_ep.empty {
            cycle 1
        }
        else {
            let r_mst = recv r_fifo_ep.pop >>
            match r_mst {
                0 => {
                        let _ = recv r_sr_le.rdy >>
                        let r_res = recv mst_ep_0.mst_r_resp >>
                        send r_sr_le.req(r_res)
                },
                1 => {
                        let _ = recv r_sr_le.rdy >>
                        let r_res = recv mst_ep_1.mst_r_resp >>
                        send r_sr_le.req(r_res)
                },
                _ => {
                        // can keep doing the match
                        ()
                }
            } >>
            cycle 1
        }
    }

    loop {
        let resp = recv r_sr_le.res >>
        send slv_ep.slv_res_r(resp) >>
        send r_sr_le.spill(1'd1) >>
        cycle 1
    }

// ------------------------------------End of the axi demux------------------------------------------------
}
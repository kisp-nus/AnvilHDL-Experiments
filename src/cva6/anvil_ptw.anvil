enum prv_lvl_e{
    PRV_M,
    PRV_S,
    PRV_U
}

enum pmp_access_t {
    ACCESS_NONE,
    ACCESS_READ,
    ACCESS_WRITE,
    NA,
    ACCESS_EXEC
}

struct pmpcfg_access_t{
    x : logic,
    w : logic,
    r : logic
}

enum pmp_addr_mode_t{
    OFF ,
    TOR ,
    NA4 ,
    NAPOT
}

enum ptw_stage_e{
    S_STAGE,
    G_INTERMED_STAGE,
    G_FINAL_STAGE
}

struct mmu_out {
    bad_gpaddr_o : logic[41],
    ptw_error_o : logic,
    ptw_access_exception_o : logic,
    bad_paddr_o : logic[56]
}

struct pmpcfg_t {
    locked : logic,
    reserved : logic[2],
    addr_mode : pmp_addr_mode_t,
    access_type : pmpcfg_access_t
}

struct pte_cva6_t {
    reserved : logic[10],
    ppn : logic[44],
    rsw : logic[2],
    d : logic,
    a : logic,
    g : logic,
    u : logic,
    x : logic,
    w : logic,
    r : logic,
    v : logic
}

struct update_in {
    is_page : logic[2],
    vpn : logic[27],
    asid : logic[16],
    content : pte_cva6_t
}

struct dcache_out_t {
    data_rid : logic[3],
    data_rdata : logic[64],
    data_ruser : logic
}

struct dcache_in_t {
    address_index : logic[12],
    address_tag : logic[44],
    data_wdata : logic[64],
    data_wuser : logic,
    data_be : logic[8],
    data_size : logic[2],
    data_id : logic[3]
}


struct shared_tlb_in {
    shared_tlb_hit_i : logic,
    itlb_req_i : logic,
    update_vaddr_i : logic[64]
}


enum stageEnum {
    IDLE,
    WAIT_GRANT,
    SEND_DCACHE_REQ,
    PTE_LOOKUP,
    WAIT_RVALID,
    PROPAGATE_ERROR,
    PROPAGATE_ACCESS_ERROR,
    LATENCY
}

struct csr_in {
    en_ld_st_translation_i : logic,
    asid_i : logic[16],
    satp_ppn_i : logic[44],
    enable_translation_i : logic
}

chan flush_ctl_ch {
    left req : (logic@#1) @#1 - @dyn
}


chan ptw_mmu_ch {
    left req : (shared_tlb_in@res),
    left csr : (csr_in@#1) @#req - @#req,
    left mxr : (logic@#1) @#1 - @#1,
    left lsu_req : (logic@#1) @#1 - @#1,
    right miss_o : (logic@#1) @#req-@#req,
    right tlb_res : (update_in@#1) @dyn - @#1,
    right update_vaddr_o : (logic[64]@#1) @#1-@#1,
    right res : (mmu_out@#1) @dyn - @#1,
    right status : (logic@#1) @#1 - @#1,
    right walking_instr_o : (logic@#1) @#1-@#1,
    left pmp_cfg : (pmpcfg_t[8]@#1) @#1 - @#1,
    left pmp_addr : (logic[8][56]@#1) @#1 - @#1
}


chan dcache_ptw_ch {
    left req : (logic@#1),
    left data_req : (dcache_in_t@#1) @#1 - @dyn,
    right data_res : (dcache_out_t@#1)
}

chan pmp_ch {
    left addr_i : (logic[56]@#1) @#1 - @#1,
    left priv_lvl_i : (prv_lvl_e@#1) @#1 - @#1,
    left access_type : (pmp_access_t@#1) @#1 - @#1,
    left pmp_addr : (logic[8][56]@#1) @#1 - @#1,
    left pmp_cfg : (pmpcfg_t[8]@#1) @#1 - @#1,
    right res : (logic@#1) @#1 - @#1
}

func get_vaddr_lvl(x) {
    if x == 2'd0 {
        *vaddr[21+:9]
    } else if x == 2'd1 {
        *vaddr[12+:9]
    } else {
        9'd0
    }
}

func missaligned_page(pte) {
    let misaligned_flag = #flat{ ((*ptw_lvl==2'd1)&&(pte.ppn[0+:9]!=9'd0)),
                            ((*ptw_lvl==2'd0)&&(pte.ppn[0+:18]!=18'd0))};
    ((misaligned_flag[0]|misaligned_flag[1])==1'd1)
}

func is_page(x) {
    *ptw_lvl == x
}

func generate_shared_tlb_update(pte) {
    update_in::{vpn = *vaddr[12+:27];is_page = #flat{call is_page(2'd1), call is_page(2'd0)};content=(pte);asid = *tlb_update_asid}
}
func get_pte_rdata(){
    pte_cva6_t::{v=*data_rdata[0];r=*data_rdata[1];w=*data_rdata[2];x=*data_rdata[3];u=*data_rdata[4];g=*data_rdata[5];a=*data_rdata[6];d=*data_rdata[7];rsw=*data_rdata[8+:2];ppn=*data_rdata[10+:44];reserved=*data_rdata[54+:10]}
}

func IDLE() {
    set ptw_lvl := 2'd0;
    {
        try _ = recv flush_ch.req {
            set stage := stageEnum::LATENCY;
            set is_instr_ptw := 1'd0
        } 
        else {
            try inp = recv mmu_ch.req {
                let csr_in = recv mmu_ch.csr >>
                if inp.shared_tlb_hit_i == 1'd0 {
                    send mmu_ch.miss_o(1'd1) >>
                    set is_instr_ptw := inp.itlb_req_i;
                    set vaddr := inp.update_vaddr_i;
                    set ptw_pptr := #flat{csr_in.satp_ppn_i, inp.update_vaddr_i[30+:9],3'd0};
                    set tlb_update_asid := csr_in.asid_i;
                    set ptw_stage := ptw_stage_e::S_STAGE;
                    set stage := stageEnum::WAIT_GRANT
                } else {
                    send mmu_ch.miss_o(1'd0) >>
                    set is_instr_ptw := 1'd0
                }
            } 
            else {
                set is_instr_ptw := 1'd0
            }
        }
    }
}

func WAIT_GRANT() {

    try send dcache_ch.req(1'd1){
        try _ = recv flush_ch.req {
            set stage := stageEnum::SEND_DCACHE_REQ
        }
        else{
            set stage := stageEnum::PTE_LOOKUP
        }
    }
    else{
        try _ = recv flush_ch.req{
            set stage := stageEnum::LATENCY
        }
        else{
            cycle 1
        }
    }
}

func SEND_DCACHE_REQ() {
    let address_index = *ptw_pptr[0+:12] >>
    let address_tag = *ptw_pptr[12+:44] >>
    send dcache_ch.data_req(dcache_in_t::{data_wdata = 64'd0;data_wuser = 1'd0;data_be = 8'd0; data_id = 3'd0;address_index=address_index;address_tag=address_tag;data_size = 2'd3}) >>
    call WAIT_RVALID()
}

func PTE_LOOKUP() {
    let address_index = *ptw_pptr[0+:12] >>
    let address_tag = *ptw_pptr[12+:44] >>
    send dcache_ch.data_req(dcache_in_t::{data_wdata = 64'd0; data_wuser = 1'd0; data_be = 8'd0; data_id = 3'd0; address_index = address_index ; address_tag=address_tag; data_size = 2'd3}) >>
    try x = recv dcache_ch.data_res {
        try _ = recv flush_ch.req {
            cycle 1 >>
            set stage := stageEnum::LATENCY
        }
        else{    
            set data_rdata := x.data_rdata >>
            try _ = recv flush_ch.req {
                set stage := stageEnum::LATENCY
            }
            else{
                let pte = call get_pte_rdata() >>
                if((pte.v==1'd0)||(((~pte.r)&pte.w)==1'd1)||(pte.reserved != 10'd0)) {
                        set stage := stageEnum::PROPAGATE_ERROR
                }
                else{
                    let pmp_access_allow = recv pmp_ep_ri.res >>
                    if pmp_access_allow == 1'd0 {
                        set stage := stageEnum::PROPAGATE_ACCESS_ERROR        
                    }
                    else if((pte.r==1'd1) || (pte.x == 1'd1)){
                        if call missaligned_page(pte) {
                            set stage := stageEnum::PROPAGATE_ERROR
                        }
                        else if (*is_instr_ptw == 1'd1){
                            if((pte.x == 1'd0) || (pte.a ==1'd0)) {
                                   set stage := stageEnum::PROPAGATE_ERROR
                            }
                            else {
                                let y= *vaddr[12+:27];
                                let page= #flat{call is_page(2'd1), call is_page(2'd0)};
                                let x = update_in::{vpn = y;is_page = page;content=pte;asid = *tlb_update_asid};
                                send mmu_ch.tlb_res(x) >>
                                set stage := stageEnum::LATENCY
                            }

                        }
                        else{
                            let lsu_is_store_i = recv mmu_ch.lsu_req >>
                            if (lsu_is_store_i == 1'd1)&&((pte.w==1'd0)||(pte.d==1'd0)) {
                                set stage := stageEnum::PROPAGATE_ERROR
                            }
                            else{
                                let mxr = recv mmu_ch.mxr >>
                                if((pte.a ==1'd1)&&((pte.r == 1'd1)||((pte.x ==1'd1)&&(mxr ==1'd1)))){
                                    let y= *vaddr[12+:27];
                                    let page= #flat{call is_page(2'd1), call is_page(2'd0)};
                                    let x = update_in::{vpn = y;is_page = page;content=(pte);asid = *tlb_update_asid};
                                    send mmu_ch.tlb_res(x) >>
                                    set stage := stageEnum::LATENCY
                                }
                                else{
                                    set stage := stageEnum::PROPAGATE_ERROR
                                }
                            }

                        }
                    }
                    else if *ptw_lvl == 2'd2 {
                        set stage := stageEnum::PROPAGATE_ERROR
                    }
                    else {
                        let x = call get_vaddr_lvl(*ptw_lvl);
                        set ptw_pptr := #flat{pte.ppn, x,3'd0};
                        set stage := stageEnum::WAIT_GRANT;
                        set ptw_lvl := *ptw_lvl + 2'd1
                    }

                }
            }
        }

    }
    else{
        try _ = recv flush_ch.req {
            set stage := stageEnum::WAIT_RVALID
        }
        else{
            cycle 1
        }
    }
}

func PROPAGATE_ERROR() {
    send mmu_ch.res(mmu_out::{bad_gpaddr_o = 41'd0; ptw_error_o=1'd1;ptw_access_exception_o =1'd0;bad_paddr_o = 56'd0}) >>
    set stage := stageEnum::LATENCY
}

func LATENCY() {
    try _ = recv flush_ch.req{
        set stage := stageEnum::LATENCY
    }
    else{
         set stage := stageEnum::IDLE
    }
}

func PROPAGATE_ACCESS_ERROR() {
    send mmu_ch.res(mmu_out::{bad_gpaddr_o = 41'd0; ptw_error_o=1'd0;ptw_access_exception_o =1'd1;bad_paddr_o = *ptw_pptr }) >>
    set stage := stageEnum::LATENCY
}

func WAIT_RVALID() {
    let x = recv dcache_ch.data_res >>
    set data_rdata := x.data_rdata >>
    set stage := stageEnum::LATENCY
}

proc pmp_extern(ep : left pmp_ch){
    loop{
        cycle 1
    }
}


proc anvil_ptw (mmu_ch : left ptw_mmu_ch, dcache_ch : right dcache_ptw_ch, flush_ch : left flush_ctl_ch)
{
    chan pmp_ep_le -- pmp_ep_ri : pmp_ch;
    spawn pmp_extern(pmp_ep_le);
    reg ptw_pptr : logic[56];
    reg data_rdata : logic[64];
    reg is_instr_ptw : logic;
    reg stage : stageEnum;
    reg vaddr : logic[64];
    reg tlb_update_asid : logic[16];
    reg pmp_access_allow : logic;
    reg ptw_lvl : logic[2];
    reg ptw_stage : ptw_stage_e;

    loop {
           
            match *stage {
                stageEnum::IDLE => call IDLE(),
                stageEnum::WAIT_GRANT => call WAIT_GRANT(),
                stageEnum::SEND_DCACHE_REQ => call SEND_DCACHE_REQ(),
                stageEnum::PTE_LOOKUP => call PTE_LOOKUP(),
                stageEnum::PROPAGATE_ERROR => call PROPAGATE_ERROR(),
                stageEnum::PROPAGATE_ACCESS_ERROR => call PROPAGATE_ACCESS_ERROR(),
                stageEnum::WAIT_RVALID => call WAIT_RVALID(),
                stageEnum::LATENCY => call LATENCY(),
                _  => call IDLE()
            }
 
    }

    loop{
        send mmu_ch.status((*stage!=stageEnum::IDLE)) >>
        send mmu_ch.walking_instr_o(*is_instr_ptw) >>
        send mmu_ch.update_vaddr_o(*vaddr) >>
        send pmp_ep_ri.addr_i(*ptw_pptr) >>
        send pmp_ep_ri.priv_lvl_i(prv_lvl_e::PRV_S) >>
        send pmp_ep_ri.access_type(pmp_access_t::ACCESS_READ) >>
        let pmp_addr_i = recv mmu_ch.pmp_addr >>
        send pmp_ep_ri.pmp_addr(pmp_addr_i) >>
        let pmp_cfg_i = recv mmu_ch.pmp_cfg >>
        send pmp_ep_ri.pmp_cfg(pmp_cfg_i) >>
        cycle 1
    }

    // loop{
    //     match *stage{
    //     stageEnum::IDLE => (),
    //     stageEnum::WAIT_GRANT => dprint "[Cycle %d] Request Recieved => Wait Grant" (*cyc),
    //     stageEnum::SEND_DCACHE_REQ => dprint "[Cycle %d] Send Dcache Req" (*cyc),
    //     stageEnum::POLL_DCACHE_RESP => dprint "[Cycle %d] Poll Dcache Resp" (*cyc),
    //     stageEnum::PTE_LOOKUP => dprint "[Cycle %d] PTE Lookup" (*cyc),
    //     stageEnum::WAIT_RVALID => dprint "[Cycle %d] Wait Rvalid" (*cyc),
    //     stageEnum::PROPAGATE_ERROR => dprint "[Cycle %d] Propagate Error" (*cyc),
    //     stageEnum::PROPAGATE_ACCESS_ERROR => dprint "[Cycle %d] Propagate Access Error" (*cyc),
    //     stageEnum::LATENCY => dprint "[Cycle %d] Latency" (*cyc),
    //     _ => ()
    //     }>>
    //     cycle 1
    // }


}



enum gpu_op{
    NOP, //4'b0000
    BRnzp, //4'b0001
    CMP, //4'b0010
    ADD, //4'b0011
    SUB, //4'b0100
    MUL, //4'b0101
    DIV, //4'b0110
    LDR, //4'b0111
    STR, //4'b1000
    CONST, //4'b1001
    NA0, //4'b1010
    NA1, //4'b1011
    NA2, //4'b1100
    NA3, //4'b1101
    NA4, //4'b1110
    RET //4'b1111
}



struct decoded_res_pack_t{
    decoded_rd_address : logic[4],
    decoded_rs_address : logic[4],
    decoded_rt_address : logic[4],
    decoded_nzp : logic[3],
    decoded_immediate : logic[8],
    
    decoded_reg_write_enable : logic,
    decoded_mem_read_enable : logic,
    decoded_mem_write_enable : logic,
    decoded_nzp_write_enable : logic,
    decoded_reg_input_mux :logic[2],
    decoded_alu_arithmetic_mux : logic[2],
    decoded_alu_output_mux :logic,
    decoded_pc_mux : logic,

    decoded_ret : logic
}


chan decoder_ch{
    left req : (logic[16]@#1) @#1 - @dyn,
    right res : (decoded_res_pack_t@req) @#req+1 - @#req+1
}


proc decoder(ep : left decoder_ch) {
    reg resp : decoded_res_pack_t;
    loop{
        let inp = recv ep.req >>
        let op = (< (inp[12+:4]) :: gpu_op >) >>
        let null_0 : decoded_res_pack_t = (< (34'd0) :: decoded_res_pack_t >) >>
        let null : decoded_res_pack_t = decoded_res_pack_t::{null_0 with decoded_rd_address = inp[8+:4]; decoded_rs_address = inp[4+:4];decoded_rt_address = inp[0+:4]; decoded_immediate = inp[0+:8]; decoded_nzp = inp[9+:3]} >>

        match op{
            gpu_op::BRnzp => {
                set resp := decoded_res_pack_t::{null with decoded_pc_mux = 1'd1}
            },
            gpu_op::CMP => {
                set resp := decoded_res_pack_t::{null with decoded_nzp_write_enable = 1'd1; decoded_alu_output_mux = 1'd1}
            },
            gpu_op::ADD => {
                set resp := decoded_res_pack_t::{null with decoded_alu_arithmetic_mux = 2'd0; decoded_reg_write_enable = 1'd1; decoded_reg_input_mux = 2'd0}
            },
            gpu_op::SUB => {
                set resp := decoded_res_pack_t::{null with decoded_alu_arithmetic_mux = 2'd1; decoded_reg_write_enable = 1'd1; decoded_reg_input_mux = 2'd0}
            },
            gpu_op::MUL => {
                set resp := decoded_res_pack_t::{null with decoded_alu_arithmetic_mux = 2'd2; decoded_reg_write_enable = 1'd1; decoded_reg_input_mux = 2'd0}
            },
            gpu_op::DIV => {
                set resp := decoded_res_pack_t::{null with decoded_alu_arithmetic_mux = 2'd3; decoded_reg_write_enable = 1'd1; decoded_reg_input_mux = 2'd0}
            },
            gpu_op::LDR => {
                set resp := decoded_res_pack_t::{null with decoded_mem_read_enable = 1'd1; decoded_reg_input_mux = 2'd1; decoded_reg_write_enable = 1'd1}
            },
            gpu_op::STR => {
                set resp := decoded_res_pack_t::{null with decoded_mem_write_enable = 1'd1}
            },
            gpu_op::CONST => {
                set resp := decoded_res_pack_t::{null with decoded_reg_write_enable = 1'd1; decoded_reg_input_mux = 2'd2}
            },
            gpu_op::RET => {
                set resp := decoded_res_pack_t::{null with decoded_ret = 1'd1}
            },
            _ => {
                set resp := null
            }
        } >>
        send ep.res(*resp)
    }
}
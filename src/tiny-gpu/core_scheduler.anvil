import "common.anvilh"
import "alu.anvil"
import "lsu.anvil"
import "registers.anvil"
import "decoder.anvil"
import "fetcher.anvil"

func do_processing(){
    //Fetch
        send fetcher_ep_ri.pc(*pc) >>
        let inst = recv fetcher_ep_ri.inst >>

        //3'b010
        send decoder_ep_ri.req(inst) >>
        let decoded_res = recv decoder_ep_ri.res >>

        //3'b011
        
        let thread_count = recv ep.thread_count >>

        let next_pc_update = match thread_count{
            3'd1 => {
                send reg_ep0_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                send lsu_ep0_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                let reg_pack = recv reg_ep0_ri.rd_res >>
                send lsu_ep0_ri.reg_pack(reg_pack) >>
                let lsu_out = recv lsu_ep0_ri.out >>
                //3'b101
                send alu_ep0_ri.req(alu_in_pack_t::{operands= reg_pack; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                send pc_ep0_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                let alu_out = recv alu_ep0_ri.res >>
                let next_pc = recv pc_ep0_ri.next_pc >>

                //3'b110
                send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out; lsu_out = lsu_out; imm = decoded_res.decoded_immediate}) >>
                if(decoded_res.decoded_nzp_write_enable){
                    send pc_ep0_ri.update_nzp(alu_out)
                } >> 
                next_pc

            },
            3'd2 => {
                {
                    send reg_ep0_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep0_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack0 = recv reg_ep0_ri.rd_res >>
                    send lsu_ep0_ri.reg_pack(reg_pack0) >>
                    let lsu_out0 = recv lsu_ep0_ri.out >>
                    //3'b101
                    send alu_ep0_ri.req(alu_in_pack_t::{operands= reg_pack0; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep0_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out0 = recv alu_ep0_ri.res >>
                    let next_pc = recv pc_ep0_ri.next_pc >>

                    //3'b110
                    send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out0; lsu_out = lsu_out0; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep0_ri.update_nzp(alu_out0)
                    }
                };

                let pc = {
                    send reg_ep1_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep1_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack1 = recv reg_ep1_ri.rd_res >>
                    send lsu_ep1_ri.reg_pack(reg_pack1) >>
                    let lsu_out1 = recv lsu_ep1_ri.out >>
                    //3'b101
                    send alu_ep1_ri.req(alu_in_pack_t::{operands= reg_pack1; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep1_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out1 = recv alu_ep1_ri.res >>
                    let next_pc = recv pc_ep1_ri.next_pc >>

                    //3'b110
                    send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out1; lsu_out = lsu_out1; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep1_ri.update_nzp(alu_out1)
                    } >>
                    next_pc
                } >>
                pc

            },
            3'd3 => {
                {
                    send reg_ep0_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep0_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack0 = recv reg_ep0_ri.rd_res >>
                    send lsu_ep0_ri.reg_pack(reg_pack0) >>
                    let lsu_out0 = recv lsu_ep0_ri.out >>
                    //3'b101
                    send alu_ep0_ri.req(alu_in_pack_t::{operands= reg_pack0; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep0_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out0 = recv alu_ep0_ri.res >>
                    let next_pc = recv pc_ep0_ri.next_pc >>

                    //3'b110
                    send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out0; lsu_out = lsu_out0; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep0_ri.update_nzp(alu_out0)
                    }
                };
                {
                    send reg_ep1_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep1_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack1 = recv reg_ep1_ri.rd_res >>
                    send lsu_ep1_ri.reg_pack(reg_pack1) >>
                    let lsu_out1 = recv lsu_ep1_ri.out >>
                    //3'b101
                    send alu_ep1_ri.req(alu_in_pack_t::{operands= reg_pack1; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep1_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out1 = recv alu_ep1_ri.res >>
                    let next_pc = recv pc_ep1_ri.next_pc >>

                    //3'b110
                    send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out1; lsu_out = lsu_out1; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep1_ri.update_nzp(alu_out1)
                    }
                };
            let next_p = {
                    send reg_ep2_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep2_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack2 = recv reg_ep2_ri.rd_res >>
                    send lsu_ep2_ri.reg_pack(reg_pack2) >>
                    let lsu_out2 = recv lsu_ep2_ri.out >>
                    //3'b101
                    send alu_ep2_ri.req(alu_in_pack_t::{operands= reg_pack2; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep2_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out2 = recv alu_ep2_ri.res >>
                    let next_pc = recv pc_ep2_ri.next_pc >>
                    
                    //3'b110
                    send reg_ep2_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out2; lsu_out = lsu_out2; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep2_ri.update_nzp(alu_out2)
                    } >> next_pc
                } >>
                next_p
            },
            _ => {
                {
                    send reg_ep0_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep0_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack0 = recv reg_ep0_ri.rd_res >>
                    send lsu_ep0_ri.reg_pack(reg_pack0) >>
                    let lsu_out0 = recv lsu_ep0_ri.out >>
                    //3'b101
                    send alu_ep0_ri.req(alu_in_pack_t::{operands= reg_pack0; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep0_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out0 = recv alu_ep0_ri.res >>
                    let next_pc = recv pc_ep0_ri.next_pc >>
                    
                    //3'b110
                    send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out0; lsu_out = lsu_out0; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep0_ri.update_nzp(alu_out0)
                    } 
                };
                {
                    send reg_ep1_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep1_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack1 = recv reg_ep1_ri.rd_res >>
                    send lsu_ep1_ri.reg_pack(reg_pack1) >>
                    let lsu_out1 = recv lsu_ep1_ri.out >>
                    //3'b101
                    send alu_ep1_ri.req(alu_in_pack_t::{operands= reg_pack1; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep1_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out1 = recv alu_ep1_ri.res >>
                    let next_pc = recv pc_ep1_ri.next_pc >>

                    //3'b110
                    send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out1; lsu_out = lsu_out1; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep1_ri.update_nzp(alu_out1)
                    }
                };
                {
                    send reg_ep2_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep2_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack2 = recv reg_ep2_ri.rd_res >>
                    send lsu_ep2_ri.reg_pack(reg_pack2) >>
                    let lsu_out2 = recv lsu_ep2_ri.out >>
                    //3'b101
                    send alu_ep2_ri.req(alu_in_pack_t::{operands= reg_pack2; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep2_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out2 = recv alu_ep2_ri.res >>
                    let next_pc = recv pc_ep2_ri.next_pc >>

                    //3'b110
                    send reg_ep2_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out2; lsu_out = lsu_out2; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep2_ri.update_nzp(alu_out2)
                    }
                };
                let p = {
                    send reg_ep3_ri.rd_req(reg_addr_pack_t::{rs_address = decoded_res.decoded_rs_address; rt_address = decoded_res.decoded_rt_address}) >>
                    send lsu_ep3_ri.req(#{decoded_res.decoded_mem_write_enable, decoded_res.decoded_mem_read_enable}) >>
                    let reg_pack3 = recv reg_ep3_ri.rd_res >>
                    send lsu_ep3_ri.reg_pack(reg_pack3) >>
                    let lsu_out3 = recv lsu_ep3_ri.out >>
                    //3'b101
                    send alu_ep3_ri.req(alu_in_pack_t::{operands= reg_pack3; op = decoded_res.decoded_alu_arithmetic_mux; out_mux = decoded_res.decoded_alu_output_mux}) >>
                    send pc_ep3_ri.req(pc_req_t::{decoded_pc_mux = decoded_res.decoded_pc_mux; current_pc = *pc;decoded_immediate = decoded_res.decoded_immediate; decoded_nzp = decoded_res.decoded_nzp}) >>
                    let alu_out3 = recv alu_ep3_ri.res >>
                    let next_pc = recv pc_ep3_ri.next_pc >>

                    //3'b110
                    send reg_ep3_ri.wr_req(reg_wr_pack_t::{addr = decoded_res.decoded_rd_address; src = decoded_res.decoded_reg_input_mux; alu_out = alu_out3; lsu_out = lsu_out3; imm = decoded_res.decoded_immediate}) >>
                    if(decoded_res.decoded_nzp_write_enable){
                        send pc_ep3_ri.update_nzp(alu_out3)
                    } >>
                    next_pc
                } >>
                p
            }
            
        } >>

        if(decoded_res.decoded_ret){
            set stage := 2'd2
        }
        else{
            set pc := next_pc_update
        }
}

proc core_scheduler(
    ep : left scheduler_ch,
    inst_ep : right inst_mem_ch,
    data_ep0 : right lsu_mem_ch,
    data_ep1 : right lsu_mem_ch,
    data_ep2 : right lsu_mem_ch,
    data_ep3 : right lsu_mem_ch
){
    reg pc : logic[8];
    reg stage : logic[2];
    chan fetcher_ep_le -- fetcher_ep_ri : fetch_ch;
    chan decoder_ep_le --  decoder_ep_ri : decoder_ch;
    
    // ALU endpoints for each thread
    chan alu_ep0_le -- alu_ep0_ri : alu_ch;
    chan alu_ep1_le -- alu_ep1_ri : alu_ch;
    chan alu_ep2_le -- alu_ep2_ri : alu_ch;
    chan alu_ep3_le -- alu_ep3_ri : alu_ch;
    
    // Register file endpoints for each thread
    chan reg_ep0_le -- reg_ep0_ri : regfile_ch;
    chan reg_ep1_le -- reg_ep1_ri : regfile_ch;
    chan reg_ep2_le -- reg_ep2_ri : regfile_ch;
    chan reg_ep3_le -- reg_ep3_ri : regfile_ch;
    
    // LSU endpoints for each thread
    chan lsu_ep0_le -- lsu_ep0_ri : lsu_ch;
    chan lsu_ep1_le -- lsu_ep1_ri : lsu_ch;
    chan lsu_ep2_le -- lsu_ep2_ri : lsu_ch;
    chan lsu_ep3_le -- lsu_ep3_ri : lsu_ch;
    
    // PC endpoints for each thread
    chan  pc_ep0_le -- pc_ep0_ri : pc_ch;
    chan pc_ep1_le -- pc_ep1_ri : pc_ch;
    chan pc_ep2_le -- pc_ep2_ri : pc_ch;
    chan pc_ep3_le -- pc_ep3_ri : pc_ch;

    spawn fetcher(fetcher_ep_le, inst_ep);
    spawn decoder(decoder_ep_le);


    spawn alu(alu_ep0_le);
    spawn alu(alu_ep1_le);
    spawn alu(alu_ep2_le);
    spawn alu(alu_ep3_le);

    spawn lsu(lsu_ep0_le, data_ep0);
    spawn lsu(lsu_ep1_le, data_ep1);
    spawn lsu(lsu_ep2_le, data_ep2);
    spawn lsu(lsu_ep3_le, data_ep3);

    spawn registers(reg_ep0_le);
    spawn registers(reg_ep1_le);
    spawn registers(reg_ep2_le);
    spawn registers(reg_ep3_le);
    loop ep.reset {
        match *stage{
            2'd0 => {
                try start = recv ep.start{
                    let thread_count = recv ep.thread_count >>
                    match thread_count{
                        3'd1 => {
                            send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id})
                        },
                        3'd2 => {
                            send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id})
                        },
                        3'd3 => {
                            send reg_ep0_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep2_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id})
                        },
                        _ => {
                            send reg_ep1_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep2_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep3_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id}) >>
                            send reg_ep3_ri.wr_req(reg_wr_pack_t::{addr = 4'd13; src = src_e::CONST; alu_out = 8'd0; lsu_out = 8'd0; imm = start.block_id})
                        }
                        
                    }  >>
                    set stage := 2'd1
                }
                else {
                    cycle 1
                }
            },
            2'd1 => call do_processing(),
            _ => {
                cycle 1
            }
        }
    } 
    loop{
        let res = recv ep.reset >>
        send decoder_ep_ri.reset(res) >>
        send fetcher_ep_ri.reset(res) >>


        send lsu_ep0_ri.reset(res) >>
        send alu_ep0_ri.reset(res) >>
        send reg_ep0_ri.reset(res) >>
        send pc_ep0_ri.reset(res) >>
        
        send lsu_ep1_ri.reset(res) >>
        send alu_ep1_ri.reset(res) >>
        send reg_ep1_ri.reset(res) >>
        send pc_ep1_ri.reset(res) >>

        send lsu_ep2_ri.reset(res) >>
        send alu_ep2_ri.reset(res) >>
        send reg_ep2_ri.reset(res) >>
        send pc_ep2_ri.reset(res) >>

        send lsu_ep3_ri.reset(res) >>
        send alu_ep3_ri.reset(res) >>
        send reg_ep3_ri.reset(res) >>
        send pc_ep3_ri.reset(res) >>
        send ep.done((*stage == 2'd2)) >>

        cycle 1
    } 
}
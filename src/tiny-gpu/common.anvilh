
const ADDR_BITS = 8;
const DATA_BITS = 16;
const NUM_CONSUMERS = 4;
const NUM_CHANNELS = 1;
const WRITE_ENABLE = 1;
const NUM_CORE = 2;
const THREAD_PER_BLOCK = 4;
const DATA_MEM_DATA_BITS = 8;
const PROGRAM_MEM_ADDR_BITS = 8;

struct reg_pack_t {
    rs : logic[8],
    rt : logic[8]
}
struct write_pack_t{
    addr : logic[8],
    data : logic[8]
}

struct reg_addr_pack_t{
    rs_address : logic[4],
    rt_address : logic[4]
}

//dcr //Dcr and dispatch
chan dcr_ch{
    left dcr_req : (logic[8]@#1) @#1 - @dyn
}
chan dcr_dispatch_ch{
    right res : (logic[8]@eternal) @#1 - @#1
}




chan core_dispatch_ch{ 
    left reset : (logic@#1) @#1 - @#1,
    left init : (start_pack_t@done) @#1 - @dyn,
    left thread_count : (logic[3]@#1) @#1 - @#1,
    right done : (logic@#1) @#1 - @dyn
}

chan dispatch_ch{
    left start : (logic@#1)@#1 - @#1,
    right done : (logic@#1)@#1 - @#1,
    left reset : (logic@#1) @#1 - @#1
}


//decoder


enum gpu_op{
    NOP, //4'b0000
    BRnzp, //4'b0001
    CMP, //4'b0010
    ADD, //4'b0011
    SUB, //4'b0100
    MUL, //4'b0101
    DIV, //4'b0110
    LDR, //4'b0111
    STR, //4'b1000
    CONST, //4'b1001
    NA0, //4'b1010
    NA1, //4'b1011
    NA2, //4'b1100
    NA3, //4'b1101
    NA4, //4'b1110
    RET //4'b1111
}

struct decoded_res_pack_t{
    decoded_rd_address : logic[4],
    decoded_rs_address : logic[4],
    decoded_rt_address : logic[4],
    decoded_nzp : logic[3],
    decoded_immediate : logic[8],
    
    decoded_reg_write_enable : logic,
    decoded_mem_read_enable : logic,
    decoded_mem_write_enable : logic,
    decoded_nzp_write_enable : logic,
    decoded_reg_input_mux :logic[2],
    decoded_alu_arithmetic_mux : logic[2],
    decoded_alu_output_mux :logic,
    decoded_pc_mux : logic,

    decoded_ret : logic
}


chan decoder_ch{
    left req : (logic[16]@#1) @#1 - @dyn,
    right res : (decoded_res_pack_t@req) @#req+1 - @#req+1
}



//fetch ch

chan fetch_ch{
    left reset : (logic@#1) @#1 - @#1,
    left pc : (logic[8]@inst) @#1 - @dyn, //To Do: replace with new sync pattern
    right inst : (logic[16]@pc) @dyn - @#1
}

chan inst_mem_ch{
    left req : (logic[8]@data) ,//@#1 - @dyn,
    right data : (logic[16]@req)// @dyn - @#1
}


//lsu


chan lsu_mem_ch{
    left read_req : (logic[8]@read_res),
    right read_res : (logic[8]@read_req),
    left write_req : (write_pack_t@write_res),
    right write_res : (logic@write_req)
}


chan lsu_ch {
    left reset : (logic@#1) @#1 - @#1,
    left req : (logic[2]@out) @#1 - @dyn, //TO do replace with new sync pattern
    left reg_pack : (reg_pack_t@out) @#req - @#req,
    right out : (logic[8]@req) @dyn - @#1
}


//pc

struct pc_req_t{
    current_pc : logic[8],
    decoded_immediate : logic[8],
    decoded_nzp : logic[3],
    decoded_pc_mux : logic
}

chan pc_ch {
    left reset : (logic@#1) @#1 - @#1,
    left req : (pc_req_t@#1) @#1 - @dyn,
    left update_nzp : (logic[8]@#1) @#1 - @dyn,
    right next_pc : (logic[8]@req) @#req+1 - @#req+1
}

enum src_e{
    ARITHMETIC,
    MEMORY,
    CONST
}



struct reg_wr_pack_t{
    addr : logic[4],
    src : src_e,
    alu_out : logic[8],
    lsu_out : logic[8],
    imm : logic[8]
}

chan regfile_ch{
    left reset : (logic@#1) @#1 - @#1,
    left block_id : (logic[8]@#1) @#1 - @#1,
    left rd_req : (reg_addr_pack_t@#1) @#1- @dyn,
    right rd_res : (reg_pack_t@#1) @#rd_req+1 - @#rd_req+1,
    left wr_req : (reg_wr_pack_t@#1) @#1 - @dyn
}


//alu



struct alu_in_pack_t{
    op : logic[2],
    out_mux : logic,
    operands : reg_pack_t
}
chan alu_ch {
    left reset : (logic@#1) @#1 - @#1,
    left req : (alu_in_pack_t@#1) @#1 - @dyn,
    right res : (logic[8]@#1) @#req+1 - @#req+1
}



struct start_pack_t{
    block_id : logic[8]
}

chan scheduler_ch{
    left reset : (logic@#1) @#1 - @#1,
    left start : (start_pack_t@#1) @dyn - @#1,
    right done : (logic@#1) @#1 - @#1,
    left thread_count : (logic[3]@#1) @#1 - @#1
}
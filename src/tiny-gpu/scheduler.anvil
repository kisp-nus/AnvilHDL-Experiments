const THREAD_PER_BLOCK = 4;

// Channel definitions from other modules
chan fetch_ch{
    left pc : (logic[8]@inst) @#1 - @dyn,
    right inst : (logic[16]@pc) @dyn - @#1
}

chan decoder_ch{
    left req : (logic[16]@#1) @#1 - @dyn,
    right res : (decoded_res_pack_t@req) @#req+1 - @#req+1
}

chan regfile_ch{
    left enable : (logic@#1) @#1 - @#1,
    left block_id : (logic[8]@#1) @#1 - @#1,
    left rd_req : (reg_addr_pack_t@#1) @#1- @dyn,
    right rd_res : (reg_pack_t@#1) @#rd_req+1 - @#rd_req+1,
    left wr_req : (wr_pack_t@#1) @#1 - @dyn
}

chan lsu_ch {
    left enable : (logic@eternal) @#1 - @#1,
    left req : (logic[2]@out) @#1 - @dyn,
    left reg_pack : (reg_pack_t@out) @#req - @#req,
    right out : (logic[8]@req) @dyn - @#1
}

chan pc_ch {
    left enable : (logic@eternal) @#1 - @#1,
    left req : (logic@next_pc) @#1 - @dyn,
    left current_pc : (logic[8]@next_pc) @#req - @#req,
    left dec_imm : (logic[8]@next_pc) @#req - @#req,
    right next_pc : (logic[8]@current_pc) @#req+1 - @#req+1,
    left decoded_nzp : (logic[3]@eternal) @#1 - @#1,
    left alu_dec_res : (logic[8]@alu_dec_res) @#1 - @dyn
}

chan alu_ch{
    // Placeholder for ALU interface
    left req : (logic@#1) @#1 - @#1,
    right res : (logic[8]@req) @#1 - @#1
}

// Import types from other modules
enum src_e{
    ARITHMETIC,
    MEMORY,
    CONST
}

struct reg_pack_t{
    rs : logic[8],
    rt : logic[8]
}

struct reg_addr_pack_t{
    rs_address : logic[4],
    rt_address : logic[4]
}

struct wr_pack_t{
    addr : logic[8],
    src : src_e,
    alu_out : logic[8],
    lsu_out : logic[8],
    imm : logic[8]
}

struct decoded_res_pack_t{
    decoded_rd_address : logic[4],
    decoded_rs_address : logic[4],
    decoded_rt_address : logic[4],
    decoded_nzp : logic[3],
    decoded_immediate : logic[8],
    
    decoded_reg_write_enable : logic,
    decoded_mem_read_enable : logic,
    decoded_mem_write_enable : logic,
    decoded_nzp_write_enable : logic,
    decoded_reg_input_mux :logic[2],
    decoded_alu_arithmetic_mux : logic[2],
    decoded_alu_output_mux :logic,
    decoded_pc_mux : logic,

    decoded_ret : logic
}



struct start_pack_t{
    thread_count : logic[3],
    block_id : logic[8]
}
chan scheduler_ch{
    left start : (start_pack_t@#1) @#dyn - @#1,
    right done : (logic@#1) @dyn - @#1,
    left thread_id : (logic[8]@#1) @dyn - @#1
}

chan program_memory_ch {
    left req : (logic[8]@res) @#1 - @dyn,
    right res : (logic[16]@req) @dyn - @#1
}



proc core_scheduler(
    ep : left scheduler_ch,
    fetch_ep : right fetch_ch,
    decoder_ep : right decoder_ch, 
    regfile_ep : right regfile_ch,
    lsu_ep : right lsu_ch,
    pc_ep : right pc_ch,
    alu_ep : right alu_ch  // ALU interface placeholder
){
    reg pc : logic[8];
    reg thread_id : logic[8];
    reg active : logic;
    reg alu_out : logic[8];
    reg lsu_out : logic[8];
    
    loop{
        // Wait for start signal and get thread ID
        try start = recv ep.start {
        let tid = recv ep.thread_id >>
        set thread_id := tid;
        set active := 1'd1;
        set pc := 8'd0 >>
        
        // Enable register file for this thread
        send regfile_ep.enable(1'd1) >>
        send regfile_ep.block_id(tid) >>
        
        // Enable PC unit
        send pc_ep.enable(1'd1) >>
        
        // Enable LSU
        send lsu_ep.enable(1'd1) >>
        
        // Execute instructions until RET or inactive
        cycle 1 >>
        
        if(*active == 1'd1){
            // FETCH stage
            send fetch_ep.pc(*pc) >>
            let inst = recv fetch_ep.inst >>
            
            // DECODE stage  
            send decoder_ep.req(inst) >>
            let dec_res = recv decoder_ep.res >>
            
            // REQUEST stage - Register read
            send regfile_ep.rd_req(reg_addr_pack_t::{
                rs_address = dec_res.decoded_rs_address;
                rt_address = dec_res.decoded_rt_address
            }) >>
            let reg_data = recv regfile_ep.rd_res >>
            
                        // EXECUTE stage - ALU operations
            if(dec_res.decoded_alu_arithmetic_mux != 2'b00 || 
               dec_res.decoded_alu_output_mux == 1'd1){
                match dec_res.decoded_alu_arithmetic_mux{
                    2'b00 => { // ADD
                        set alu_out := reg_data.rs + reg_data.rt
                    },
                    2'b01 => { // SUB  
                        set alu_out := reg_data.rs - reg_data.rt
                    },
                    2'b10 => { // MUL - placeholder for now
                        set alu_out := reg_data.rs + reg_data.rt  // TODO: implement multiplication
                    },
                    2'b11 => { // DIV - placeholder for now
                        set alu_out := reg_data.rs - reg_data.rt  // TODO: implement division
                    },
                    _ => {
                        set alu_out := 8'd0
                    }
                } >>
                
                // For CMP operation, compute NZP flags
                if(dec_res.decoded_alu_output_mux == 1'd1){
                    let cmp_result = reg_data.rs - reg_data.rt >>
                    if(cmp_result == 8'd0){
                        set alu_out := 8'b00000010  // Zero flag
                    }
                    else if(cmp_result[7] == 1'd1){
                        set alu_out := 8'b00000100  // Negative flag
                    }
                    else{
                        set alu_out := 8'b00000001  // Positive flag
                    }
                } >>
                
                // Update NZP flags if needed
                if(dec_res.decoded_nzp_write_enable == 1'd1){
                    send pc_ep.alu_dec_res(*alu_out)
                }
            } >>
            
            // Memory operations (LDR, STR)
            if(dec_res.decoded_mem_read_enable == 1'd1 || 
               dec_res.decoded_mem_write_enable == 1'd1){
                if(dec_res.decoded_mem_read_enable == 1'd1){
                    send lsu_ep.req(2'b01) >>
                    send lsu_ep.reg_pack(reg_data) >>
                    let lsu_result = recv lsu_ep.out >>
                    set lsu_out := lsu_result
                }
                else if(dec_res.decoded_mem_write_enable == 1'd1){
                    send lsu_ep.req(2'b10) >>
                    send lsu_ep.reg_pack(reg_data) >>
                    let lsu_result = recv lsu_ep.out >>
                    set lsu_out := lsu_result
                }
            } >>
            
            // UPDATE stage - Register writeback
            if(dec_res.decoded_reg_write_enable == 1'd1){
                match dec_res.decoded_reg_input_mux{
                    2'b00 => { // ALU result
                        send regfile_ep.wr_req(wr_pack_t::{
                            addr = (<(8'd0 | dec_res.decoded_rd_address) :: logic[8]>);
                            src = src_e::ARITHMETIC;
                            alu_out = *alu_out;
                            lsu_out = *lsu_out;
                            imm = dec_res.decoded_immediate
                        })
                    },
                    2'b01 => { // Memory result
                        send regfile_ep.wr_req(wr_pack_t::{
                            addr = (<(8'd0 | dec_res.decoded_rd_address) :: logic[8]>);
                            src = src_e::MEMORY;
                            alu_out = *alu_out;
                            lsu_out = *lsu_out;
                            imm = dec_res.decoded_immediate
                        })
                    },
                    2'b10 => { // Immediate constant
                        send regfile_ep.wr_req(wr_pack_t::{
                            addr = (<(8'd0 | dec_res.decoded_rd_address) :: logic[8]>);
                            src = src_e::CONST;
                            alu_out = *alu_out;
                            lsu_out = *lsu_out;
                            imm = dec_res.decoded_immediate
                        })
                    },
                    _ => {
                        cycle 1
                    }
                }
            } >>
            
            // PC UPDATE stage
            if(dec_res.decoded_ret == 1'd1){
                set active := 1'd0 >>
                // Disable units
                send regfile_ep.enable(1'b0) >>
                send pc_ep.enable(1'b0) >>
                send lsu_ep.enable(1'b0)
            }
            else{
                send pc_ep.req(dec_res.decoded_pc_mux) >>
                send pc_ep.current_pc(*pc) >>
                send pc_ep.dec_imm(dec_res.decoded_immediate) >>
                send pc_ep.decoded_nzp(dec_res.decoded_nzp) >>
                let next_pc = recv pc_ep.next_pc >>
                set pc := next_pc
            }
        }
        else{
            cycle 1
        }
    }
}
// import "lib/Reg.anvil"
// import "lib/Add.anvil"
// import "lib/Mux.anvil"
// import "lib/SubtractDelayed.anvil"

chan SubtractDelayed_itfc<T : type> {
    left input_l : (T@#1) @#1-@dyn,
    left input_r : (T@#1) @#input_l-@#input_l,
    right output : (T@#1) @#input_l+2-@#input_l+2
}

proc SubtractDelayed<T : type> (endp : left SubtractDelayed_itfc<T>) {
    reg r0 : T;
    reg r1 : T;

    recursive {
        let l = recv endp.input_l >>
        {
            {
                let r = recv endp.input_r >>
                set r0 := l - r >>
                set r1 := *r0 >>
                send endp.output (*r1)
            };
            cycle 1 >> recurse
        }
    }
}
chan Add_itfc<T : type> {
    left input_l : (T@#1) @#1-@dyn,
    left input_r : (T@#1) @#input_l-@#input_l,
    right output : (T@#1) @#input_l-@#input_l
}

proc Add<T : type> (endp : left Add_itfc<T>) {
    loop {
        let l = recv endp.input_l >>
        let r = recv endp.input_r >>
        send endp.output (l + r) >>
        cycle 1
    }
}


chan Alu_itfc<T : type> {
    left input_l : (T@#1) @#1-@dyn,
    left input_r : (T@#1) @#input_l-@#input_l,
    left input_op : (logic@#1) @#input_l+2-@#input_l+2,
    right output : (T@#1) @#input_l+2-@#input_l+2
}

proc Alu<T : type> (endp : left Alu_itfc<T>) {
    // chan mux_le -- mux_ri : Mux_itfc<T>;
    chan add_le -- add_ri : Add_itfc<T>;
    // chan reg0_le -- reg0_ri : Reg_itfc<T>;
    // chan reg1_le -- reg1_ri : Reg_itfc<T>;
    chan sub_le -- sub_ri : SubtractDelayed_itfc<T>;
    spawn Add<T> (add_le);
    // spawn Mux<T> (mux_le);
    // spawn Reg<T> (reg0_le);
    // spawn Reg<T> (reg1_le);
    spawn SubtractDelayed<T> (sub_le);
    reg s1 : T;
    reg s2 : T;

    recursive {
        let l = recv endp.input_l >> {
            {
                let r = recv endp.input_r >>
                let result = {
                    let add_res = (
                        send add_ri.input_l (l) >>
                        send add_ri.input_r (r) >>
                        let res_add = recv add_ri.output >>
                        set s1 := res_add >>
                        set s2 := *s1 >>
                        *s2
                    );
                    let sub_res = (
                        send sub_ri.input_l (l) >>
                        send sub_ri.input_r (r) >>
                        cycle 2 >> recv sub_ri.output
                    );
                    add_res >> sub_res >>
                    let concat_res = #{sub_res,add_res} >>
                    let op = recv endp.input_op >>
                    concat_res[op]                    
                } >>
                send endp.output (result)
            };
            cycle 1 >> recurse
        }
    }
}

proc pipelined_alu() {
    chan alu_le -- alu_ri : Alu_itfc<logic[32]>;
    spawn Alu<logic[32]> (alu_le);

    loop{
        send alu_ri.input_l (32'd1) >>
        send alu_ri.input_r (32'd1) >>
        cycle 1 >>
        cycle 1
    }
    loop{
        cycle 2 >>
        send alu_ri.input_op (1'd0) >>
        let x = recv alu_ri.output  >>
        dprint "Recieved %d" (x) >>
        dfinish >>
        cycle 1
    }
}
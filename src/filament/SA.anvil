chan Prev_Itfc{
    left input : (logic[32]@#1) @#prev-@#prev,
    right prev : (logic[32]@#1) @#1-@dyn
}
chan FastMult_Itfc{
    left input_l : (logic[32]@#1) @#1-@dyn,
    left input_r : (logic[32]@#1) @#input_l-@#input_l,
    right output : (logic[32]@#1) @#input_l+3-@#input_l+3
}
chan MultComb_Itfc{
    left input_l : (logic[32]@#1) @#1-@dyn,
    left input_r : (logic[32]@#1) @#input_l-@#input_l,
    right output : (logic[32]@#1) @#input_l-@#input_l
}

chan Add_itfc {
    left input_l : (logic[32]@#1) @#1-@dyn,
    left input_r : (logic[32]@#1) @#input_l-@#input_l,
    right output : (logic[32]@#1) @#input_l-@#input_l
}

chan Main_Itfc{
    left input_l0 : (logic[32]@#1) @#1-@dyn,
    left input_l1 : (logic[32]@#1) @#input_l0-@#input_l0,
    left input_t0 : (logic[32]@#1) @#input_l0-@#input_l0,
    left input_t1 : (logic[32]@#1) @#input_l0-@#input_l0,
    right out00 : (logic[32]@#1) @#input_l0+3-@#input_l0+3,
    right out01 : (logic[32]@#1) @#input_l0+3-@#input_l0+3,
    right out10 : (logic[32]@#1) @#input_l0+3-@#input_l0+3,
    right out11 : (logic[32]@#1) @#input_l0+3-@#input_l0+3
}

proc Add (endp : left Add_itfc) {
    loop {
        let l = recv endp.input_l >>
        let r = recv endp.input_r >>
        send endp.output (l + r) >>
        cycle 1
    }
}

proc MultComb(endp : left MultComb_Itfc){
    loop{
        let l = recv endp.input_l >>
        let r = recv endp.input_r >>
        send endp.output (l + r)>>
        cycle 1
    }
}
// Add MultComb Implementation
proc FastMult(endp : left FastMult_Itfc){
    reg l : logic[32];
    reg r : logic[32];
    reg ot : logic[32];
    reg final : logic[32];
    chan mult_ri -- multComb_ep : MultComb_Itfc;
    spawn MultComb(mult_ri);
    recursive{
                let le = recv endp.input_l >>
                {
                    {
                        let ri = recv endp.input_r >>
                        {set l := le;
                        set r := ri} >>
                        send multComb_ep.input_l (*l) >>
                        send multComb_ep.input_r (*r) >>
                        let mult_res = recv multComb_ep.output >>
                        set ot := mult_res >>
                        set final := *ot >>
                        send endp.output (*final)
                    };cycle 1 >> recurse
                }
    }
}

// proc Prev(endp : left Prev_Itfc){
//     reg prev : logic[32];
//     loop{
//         send endp.prev (*prev) >>
//         let l = recv endp.input >>
//         set prev := l
//     }
    
// }
    
proc Process(endp : left FastMult_Itfc){
    chan fast_mult_le -- fast_mult_ri : FastMult_Itfc;
    // chan prev_le -- prev_ri : Prev_Itfc;
    chan add_le -- add_ri : Add_itfc<logic[32]>;
    reg prev : logic[32];
    spawn FastMult(fast_mult_le);
    spawn Add(add_le);
    recursive{
        let l = recv endp.input_l >>{
            {
                let r = recv endp.input_r >>
                send fast_mult_ri.input_l (l) >>
                send fast_mult_ri.input_r (r) >>
                cycle 3 >>
                let mult_res = recv fast_mult_ri.output >>
                let acc_prev = *prev >>
                send add_ri.input_l (acc_prev) >>
                send add_ri.input_r (mult_res) >>
                let add_out = recv add_ri.output >>
                set prev := add_out;
                send endp.output (add_out)
            };cycle 1 >> recurse
        }
    }
}

proc SA(ep : left Main_Itfc){
    // chan prev_le1 -- prev_ri1 : Prev_Itfc;
    // chan prev_le2 -- prev_ri2 : Prev_Itfc;
    // chan prev_le3 -- prev_ri3 : Prev_Itfc;
    // chan prev_le4 -- prev_ri4 : Prev_Itfc;
    chan proc_le1 -- proc_ri1 : FastMult_Itfc;
    chan proc_le2 -- proc_ri2 : FastMult_Itfc;
    chan proc_le3 -- proc_ri3 : FastMult_Itfc;
    chan proc_le4 -- proc_ri4 : FastMult_Itfc;
    spawn Process(proc_le1);
    spawn Process(proc_le2);
    spawn Process(proc_le3);
    spawn Process(proc_le4);
    reg prev_ri1 : logic[32];
    reg prev_ri2 : logic[32];
    reg prev_ri3 : logic[32];
    reg prev_ri4 : logic[32];
    recursive{
      let l0 = recv ep.input_l0 >>
      {
        {
            let l1 = recv ep.input_l1 >>
            let t0 = recv ep.input_t0 >>
            let t1 = recv ep.input_t1 >>


            let r00_01 = *prev_ri1 >>
            let r00_10 = *prev_ri2 >>
            let r10_11 = *prev_ri3 >>
            let r01_11 = *prev_ri4 >>

            // send prev_ri1.input (l0) >>
            // send prev_ri2.input (t0) >>
            // send prev_ri3.input (l1) >>
            // send prev_ri4.input (t1) >>
            set prev_ri1 := l0;
            set prev_ri2 := t0;
            set prev_ri3 := l1;
            set prev_ri4 := t1;

            {
                send proc_ri1.input_l (l0) >>
                send proc_ri1.input_r (t0) >>
                send proc_ri2.input_l (r00_01) >>
                send proc_ri2.input_r (t1) >>
                send proc_ri3.input_l (l1) >>
                send proc_ri3.input_r (r00_10) >>
                send proc_ri4.input_l (r10_11) >>
                send proc_ri4.input_r (r01_11) >>
            

                cycle 3 >>
                let out0 = recv proc_ri1.output >>
                let out1 = recv proc_ri2.output >>
                let out2 = recv proc_ri3.output >>
                let out3 = recv proc_ri4.output >>

                send ep.out00 (out0) >>
                send ep.out01 (out1) >>
                send ep.out10 (out2) >>
                send ep.out11 (out3)
                
            }
                
    };cycle 1 >> recurse
   }
}

}
chan stream_fifo_ch <dtype : type> {
    left flush : (logic@#1) @#1 - @#1,
    left push : (dtype@#1),
    right pop : (dtype@#1)
}

proc stream_fifo <Depth : int, SameCycleRW : int, type_t : type, WIDTH : int> (ep : left stream_fifo_ch<type_t>) {
    reg stream_fifo : type_t[Depth];
    reg head : logic[WIDTH];
    reg tail : logic[WIDTH];
    reg full : logic;
    loop ep.flush {
        let empty = (*head == *tail)&&(*full == 1'd0) >>
        let fulli = (*head == *tail)&&(*full == 1'd1) >>
        if(~empty){
            try send ep.pop(*stream_fifo[*head]){
                
                set head := *head + 3'd1;
                {
                    try inp = recv ep.push{
                        set stream_fifo[*tail] := inp;
                        set tail := *tail + 3'd1
                    }
                    else {
                        set full := 1'd0
                    }
                }
            }
            else{
                if(~fulli){
                    try inp = recv ep.push{
                        set stream_fifo[*tail] := inp;
                        set full := (*head == (*tail+3'd1));
                        set tail := *tail + 3'd1
                    }
                    else{
                        set full := *full
                    }
                }
                else{
                    set full := *full
                }
            }
        }
        else{
            try inp = recv ep.push{
                set stream_fifo[*tail] := inp;
                set full := (*head == (*tail+3'd1));
                set tail := *tail + 3'd1
            }
            else{
                set full := *full
            }
        }
    }
}
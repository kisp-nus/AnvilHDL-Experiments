chan spill_ch<Tp : type> {
    right req : (Tp@#1) @dyn - @#1,
    left res : (Tp@#1) @#1 - @dyn,
    left rdy : (logic@#1) @#1 - @#1,
    right spill : (logic@#1) @dyn - @#1
}

proc spill_reg<id: int, Tp : type, BYPASS : int> (ep : right spill_ch<Tp>) {
    reg full : logic[2];
    reg spreg : Tp[2];

    loop {
    
        let a_full = *full[0];
        let b_full = *full[1];
        let a_q = *spreg[0];
        let b_q = *spreg[1];
        let ready_o = (*full != 2'b11);
        let a_drain = (a_full & (~ b_full));
        let valid_o = (a_full | b_full) >>
       if(valid_o == 1'b1) {
            // dprint "[Cycle %d] Spill Register %d: Valid Output %b, A Full %b, B Full %b" (*cyc, id, valid_o, a_full, b_full) >>
            if (b_full) {
                send ep.res(b_q)
            }
            else{
                send ep.res(a_q)
            }
        } 
        else{
            ()
        }>>
        
        if ((ready_o) == 1'd1) {
            try a = recv ep.req {
                
                // a_fill - 1'b1
                set spreg[0] := a;
                set full[0] := 1'b1;

                    try _ = recv ep.spill {
                        //ready_i = 1
                        // b_fill = 0
                        // b_drain  = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        //ready_i = 0
                        //b_fill = a_drain
                        //b_drain =0
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
            
            } else {
                //a_fill =0 
                if (a_drain) {
                    set full[0] := 1'b0
                }
                else{
                    cycle 1
                };
                // if (valid_o) {
                //     let resp = if (b_full) {
                //         b_q
                //     } else {
                //         a_q
                //     };
                try _ = recv ep.spill {
                        //ready_i = 1
                        //b_fill = 0
                        //b_drain = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
                // }
            }
        } else {
            // if (valid_o) {
            //     let resp = if (b_full) {
            //         b_q
            //     } else {
            //         a_q
            //     };
                try _ = recv ep.spill {
                    //ready_i = 1
                    //b_fill = 0
                    //b_drain = b_full
                    if (b_full) {
                        set full[1] := 1'b0
                    }
                    else{
                        cycle 1
                    }
                }

                else{
                    if (a_drain) {
                        set spreg[1] := a_q;
                        set full[1] := 1'd1
                    }
                    else{
                        cycle 1
                    }
                    
                }
            // }
            // else{
            //     cycle 1
            // }
        }
        
    }
    loop{
        let ready_o = (*full != 2'b11);
        send ep.rdy(ready_o) >>
        cycle 1
    }
}




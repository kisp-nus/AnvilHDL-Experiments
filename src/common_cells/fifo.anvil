chan fifo_ch<Tp : type> {
    left push : (Tp@#1) @#1 - @dyn,
    left pop : (logic@#1) @#1 - @dyn,
    right data_o : (Tp@#1) @#1 - @#1,
    right full : (logic@#1) @#1 - @#1,
    right empty : (logic@#1) @#1 - @#1
}

proc fifo < data_t : type, depth: int, address_depth : int>(ep : left fifo_ch<data_t>) {
    reg mem : data_t[depth];
    reg head : logic[address_depth];
    reg tail : logic[address_depth];
    reg full : logic;

    loop{
        if (*full == 1'b0){
            {
                try inp = recv ep.push {
                    set mem[*tail] := inp;
                    set tail := *tail + 3'd1
                }
                else{
                    cycle 1
                }
            };
            {// pop logic
                if (*tail != *head){
                    try _ = recv ep.pop {
                        // send ep.data_o(*mem[*head]) >>
                        set head := *head + 3'd1
                    }
                    else{
                        cycle 1
                    }
                }
                else{
                    cycle 1
                }
            };
            {
                let pop_i = ready ep.pop;
                let push_i = ready ep.push;
                if (((*tail + 3'd1) == *head)&&(push_i)){
                    if(~pop_i){
                        set full:=  1'b1
                    }
                    else{
                        set full := 1'b0
                    }
                }
                else{
                    set full := 1'b0
                }
            }

                
            }
            else{
                //if full
                try _ = recv ep.pop {
                    // send ep.data_o(*mem[*head]) >>
                    set head := *head + 3'd1;
                    set full := 1'b0
                }
                else{
                    cycle 1
                }
                
            }
    }
    loop{
        let out = if((*full == 1'b0)&&(*head == *tail)){
            1'b1
        }
        else{
            1'b0
        } >>
        send ep.empty(out) >>
        send ep.full(*full) >>
        send ep.data_o(*mem[*head]) >>
        cycle 1
    }
    
}


// proc fifo() {
//     chan ep_le -- ep_ri : fifo_ch<select_t>;
//     spawn fifo_ext<8,3>(ep_le);
//     reg cyc : logic[32];
//     loop {
//         set cyc := *cyc + 32'd1
//     }
// }
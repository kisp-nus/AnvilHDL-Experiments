// This is the fair arbiter configuration hence it makes the assumption concrete with the timing contracts
struct req_pack_t{
    data  : logic[32],
    id    : logic[3]
}

struct req_t {
    req : req_pack_t,
    valid : logic
}

chan arb_slv_ch <dtype : type> {
    left req : (logic@#1) @#1 - @#1,
    left data : (dtype@#1) @#1 - @#1,
    right gnt : (logic@#1) @#1 - @#1
}

chan arb_mst_ch <dtype : type, IDX_WIDTH : int> {
    left req : (dtype@#1) @#1 - @dyn,
    right gnt : (logic@#1) @#1 - @#1,
    left idx_o : (logic[IDX_WIDTH]@#1) @#req - @#req
}
chan flush_ch{
    left ext_id : (logic[3]@#1) @#1 - @#1,
    left flush : (logic@#1) @#1 -@#1
}


// Right now we have to manually instantiate the number of slave channels but after parametrization we can do it automatically


func get_active_req(){
    // Collect all requests first
    let req_0 = recv slv_ep_0.req >>
    let req_1 = recv slv_ep_1.req >>
    let req_2 = recv slv_ep_2.req >>
    let req_3 = recv slv_ep_3.req >>
    let req_4 = recv slv_ep_4.req >>
    let req_5 = recv slv_ep_5.req >>
    let req_6 = recv slv_ep_6.req >>
    let req_7 = recv slv_ep_7.req >>

    // Create request vector
    let req_vec = #flat{req_7, req_6, req_5, req_4, req_3, req_2, req_1, req_0} >>
    
    if(req_vec == 8'd0){
        #flat{*rr,4'd8}
    }
    else{
        // Create upper and lower masks based on round-robin pointer
        let upper_mask = match *rr {
            3'd0 => req_vec & 8'b11111111,  // mask[7:1]
            3'd1 => req_vec & 8'b11111110,  // mask[7:2]
            3'd2 => req_vec & 8'b11111100,  // mask[7:3]
            3'd3 => req_vec & 8'b11111000,  // mask[7:4]
            3'd4 => req_vec & 8'b11110000,  // mask[7:5]
            3'd5 => req_vec & 8'b11100000,  // mask[7:6]
            3'd6 => req_vec & 8'b11000000,  // mask[7:7]
            _ => req_vec & 8'b10000000                       // no upper mask for rr=7
        } >>
        
        let lower_mask = match *rr {
            3'd0 => req_vec & 8'b00000000,  // mask[0:0]
            3'd1 => req_vec & 8'b00000001,  // mask[1:0]
            3'd2 => req_vec & 8'b00000011,  // mask[2:0]
            3'd3 => req_vec & 8'b00000111,  // mask[3:0]
            3'd4 => req_vec & 8'b00001111,  // mask[4:0]
            3'd5 => req_vec & 8'b00011111,  // mask[5:0]
            3'd6 => req_vec & 8'b00111111,  // mask[6:0]
            _ => req_vec & 8'b01111111                    // all bits for rr=7
        } >>
        
        // Find first set bit in upper mask (priority encoder)
        let upper_idx = if(upper_mask[0]){ 4'd0 }
                       else if(upper_mask[1]){ 4'd1 }
                       else if(upper_mask[2]){ 4'd2 }
                       else if(upper_mask[3]){ 4'd3 }
                       else if(upper_mask[4]){ 4'd4 }
                       else if(upper_mask[5]){ 4'd5 }
                       else if(upper_mask[6]){ 4'd6 }
                       else if(upper_mask[7]){ 4'd7 }
                       else { 4'd0 } >>
        
        // Find first set bit in lower mask (priority encoder)
        let lower_idx = if(lower_mask[0]){ 4'd0 }
                       else if(lower_mask[1]){ 4'd1 }
                       else if(lower_mask[2]){ 4'd2 }
                       else if(lower_mask[3]){ 4'd3 }
                       else if(lower_mask[4]){ 4'd4 }
                       else if(lower_mask[5]){ 4'd5 }
                       else if(lower_mask[6]){ 4'd6 }
                       else if(lower_mask[7]){ 4'd7 }
                       else { 4'd0 } >>

        // Select index: use upper if available, otherwise lower
        let selected_idx : logic[4] = if(upper_mask != 8'd0){ upper_idx } else { lower_idx } >>
        
        let next_mask = match selected_idx {
            4'd0 => req_vec & 8'b11111110,  // requests after index 0
            4'd1 => req_vec & 8'b11111100,  // requests after index 1
            4'd2 => req_vec & 8'b11111000,  // requests after index 2
            4'd3 => req_vec & 8'b11110000,  // requests after index 3
            4'd4 => req_vec & 8'b11100000,  // requests after index 4
            4'd5 => req_vec & 8'b11000000,  // requests after index 5
            4'd6 => req_vec & 8'b10000000,  // requests after index 6
            _ => 8'd0                       // no requests after index 7
        } >>
        
        // Find next index for fair arbitration
        let next_idx : logic[3] = if(next_mask[1]){ 3'd1}
                      else if(next_mask[2]){ 3'd2 }
                      else if(next_mask[3]){ 3'd3 }
                      else if(next_mask[4]){ 3'd4 }
                      else if(next_mask[5]){ 3'd5 }
                      else if(next_mask[6]){ 3'd6 }
                      else if(next_mask[7]){ 3'd7 }
                      else if(req_vec[0]){ 3'd0 }  // wrap around to start
                      else {*rr } >>
        
    
        #flat{next_idx, selected_idx}
    }
}

func set_rr(served_idx : logic[3], granted : logic, next_idx : logic[3]){
    if(granted){
        set rr := next_idx
    }
    else{
        set rr := *rr
    }
}

func send_slv_res(data : logic[32],valid : logic,id : logic[3], next_idx : logic[3]){
    
    if(valid){
        send mst_ep.req(data) >>
        send mst_ep.idx_o(id)
    } >>
    let gnt = recv mst_ep.gnt >>
    let op = #flat{7'd0, (gnt&valid)} >>
    let idx = #flat{5'd0,id} >>
    let resp : logic[8] = (op << idx) >>
    send slv_ep_0.gnt(resp[0]) >>
    send slv_ep_1.gnt(resp[1]) >>
    send slv_ep_2.gnt(resp[2]) >>
    send slv_ep_3.gnt(resp[3]) >>
    send slv_ep_4.gnt(resp[4]) >>
    send slv_ep_5.gnt(resp[5]) >>
    send slv_ep_6.gnt(resp[6]) >>
    send slv_ep_7.gnt(resp[7]) >>
    let granted_mask : logic[3] = #{(gnt&valid),(gnt&valid),(gnt&valid)} >>
    let granted_flip : logic[3] = ~ granted_mask >>
    set rr := (((*rr)&(granted_flip) )|((next_idx)&(granted_flip)))
}




// proc rr_arbiter <dtype : type , ExtPrio : int, AxiVldRdy : int, LockIn : int, FairArb : int, IDX_WIDTH : int> (
proc rr_arbiter(
    slv_ep_0 : left arb_slv_ch<logic[32]>,
    slv_ep_1 : left arb_slv_ch<logic[32]>,
    slv_ep_2 : left arb_slv_ch<logic[32]>,
    slv_ep_3 : left arb_slv_ch<logic[32]>,
    slv_ep_4 : left arb_slv_ch<logic[32]>,
    slv_ep_5 : left arb_slv_ch<logic[32]>,
    slv_ep_6 : left arb_slv_ch<logic[32]>,
    slv_ep_7 : left arb_slv_ch<logic[32]>,
    mst_ep : right arb_mst_ch<logic[32], 3>,
    ep : left flush_ch
) {
    reg rr : logic[3];
    loop ep.flush{
        let result : logic[7] = call get_active_req() >>
        let selected_idx = result[0+:4] >>
        let next_idx = result[4+:3] >>
        let data_0 = recv slv_ep_0.data >>
        let data_1 = recv slv_ep_1.data >>
        let data_2 = recv slv_ep_2.data >>
        let data_3 = recv slv_ep_3.data >>
        let data_4 = recv slv_ep_4.data >>
        let data_5 = recv slv_ep_5.data >>
        let data_6 = recv slv_ep_6.data >>
        let data_7 = recv slv_ep_7.data >>
        let all_data = #{data_7, data_6, data_5, data_4, data_3, data_2, data_1, data_0} >>
        call send_slv_res(all_data[selected_idx[0+:3]], (~ (selected_idx[3])), selected_idx[0+:3], next_idx[0+:3])

    }
}


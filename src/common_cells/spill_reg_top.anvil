import "spill_reg.anvil"
extern import "spill_register.sv"


// proc spill_reg_extern(ep : right spill_ch<logic[4]>) extern("spill_register #( .T(logic[3:0]), .Bypass(1'b0))"){
//     clk_i("clk_i");
//     rst_ni("rst_ni");
//     ep.req("data_i" : "valid_i" :);
//     ep.res("data_o" : "valid_o" :);
//     ep.rdy("ready_o" : :);
//     ep.spill( : "ready_i" :);
// }

func send_req(inp){
    let r = recv ep_le.rdy >>
    if(r==1'd0){
        dprint "[Cycle %d] spill reg is busy" (*cyc)
    }
    else{
        send ep_le.req(inp) >>
        dprint "[Cycle %d] Sent req %d" (*cyc, inp)
    }
}

func recv_res(){
    let r = recv ep_le.res >>
    dprint "[Cycle %d] Received res %d" (*cyc, r) >>
    send ep_le.spill(1'd1)

}

proc spill_reg_top(){
    chan ep_le -- ep_ri : spill_ch<logic[32]>;
    spawn spill_reg<1,logic[32], 0>(ep_ri);
    // spawn spill_reg_extern(ep_ri);
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }
    loop{
        
        //===================Test 1=========================
        call send_req(32'd1) >>
        call recv_res() >>
        cycle 1 >>
        //===================Test 2=========================
            call send_req(32'd2) >>
            cycle 1 >>
            call send_req(32'd3) >>
            dprint "[Cycle %d] Sent req 2 and 3 Now trying to recv" (*cyc) >>
            call recv_res() >>
            cycle 1 >>
            call recv_res() >>
            cycle 1 >>
        // ===================Test 3=========================
            call send_req(32'd4) >>
            cycle 1 >>
            call send_req(32'd5) >>
            cycle 1 >>
            call send_req(32'd6) >>
            cycle 1 >>
            dfinish >>
            cycle 1
    }
}

import "aes_pkg.anvilh"
import "aes_key_expand.anvil"
import "aes_shift_rows.anvil"
import "aes_mix_columns.anvil"
import "aes_sub_bytes.anvil"

func print_encryption_key(key : logic[8][32]){
        dprint "[Cycle %d] [Enc Key Row 0] %h, %h, %h, %h" (*cycle_count ,key[0][24+:8], key[0][16+:8], key[0][8+:8], key[0][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 1] %h, %h, %h, %h" (*cycle_count ,key[1][24+:8], key[1][16+:8], key[1][8+:8], key[1][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 2] %h, %h, %h, %h" (*cycle_count ,key[2][24+:8], key[2][16+:8], key[2][8+:8], key[2][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 3] %h, %h, %h, %h" (*cycle_count ,key[3][24+:8], key[3][16+:8], key[3][8+:8], key[3][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 4] %h, %h, %h, %h" (*cycle_count ,key[4][24+:8], key[4][16+:8], key[4][8+:8], key[4][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 5] %h, %h, %h, %h" (*cycle_count ,key[5][24+:8], key[5][16+:8], key[5][8+:8], key[5][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 6] %h, %h, %h, %h" (*cycle_count ,key[6][24+:8], key[6][16+:8], key[6][8+:8], key[6][0+:8]) >>
        dprint "[Cycle %d] [Enc Key Row 7] %h, %h, %h, %h" (*cycle_count ,key[7][24+:8], key[7][16+:8], key[7][8+:8], key[7][0+:8])
}
func print_decryption_key(key : logic[8][32]){
        dprint "[Cycle %d] [Dec Key Row 0] %h, %h, %h, %h" (*cycle_count, key[0][24+:8], key[0][16+:8], key[0][8+:8], key[0][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 1] %h, %h, %h, %h" (*cycle_count, key[1][24+:8], key[1][16+:8], key[1][8+:8], key[1][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 2] %h, %h, %h, %h" (*cycle_count, key[2][24+:8], key[2][16+:8], key[2][8+:8], key[2][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 3] %h, %h, %h, %h" (*cycle_count, key[3][24+:8], key[3][16+:8], key[3][8+:8], key[3][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 4] %h, %h, %h, %h" (*cycle_count, key[4][24+:8], key[4][16+:8], key[4][8+:8], key[4][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 5] %h, %h, %h, %h" (*cycle_count, key[5][24+:8], key[5][16+:8], key[5][8+:8], key[5][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 6] %h, %h, %h, %h" (*cycle_count, key[6][24+:8], key[6][16+:8], key[6][8+:8], key[6][0+:8]) >>
        dprint "[Cycle %d] [Dec Key Row 7] %h, %h, %h, %h" (*cycle_count, key[7][24+:8], key[7][16+:8], key[7][8+:8], key[7][0+:8])
}


func print_cipher_state(cipher_state : logic[4][4][8]){
    dprint "[Cycle %d] Cipher State" (*cycle_count);
    dprint "[Cipher Row 0] %h, %h, %h, %h" (cipher_state[0][0], cipher_state[0][1], cipher_state[0][2], cipher_state[0][3]);
    dprint "[Cipher Row 1] %h, %h, %h, %h" (cipher_state[1][0], cipher_state[1][1], cipher_state[1][2], cipher_state[1][3]);
    dprint "[Cipher Row 2] %h, %h, %h, %h" (cipher_state[2][0], cipher_state[2][1], cipher_state[2][2], cipher_state[2][3]);
    dprint "[Cipher Row 3] %h, %h, %h, %h" (cipher_state[3][0], cipher_state[3][1], cipher_state[3][2], cipher_state[3][3])
}


proc aes_cipher_core(ep : left aes_core_ch, entr_ep : right entropy_ch<128>){
    chan key_le -- key_ri : aes_key_expand_ch;
    chan shift_rows_le -- shift_rows_ri : shift_rows_ch;
    chan mix_col_le -- mix_col_ri : mix_column_ch;
    chan key_mix_le -- key_mix_ri : mix_column_ch;
    chan sub_bytes_le -- sub_bytes_ri : sub_bytes_ch;
    spawn aes_key_expand(key_le);
    spawn aes_shift_rows(shift_rows_le);
    spawn aes_mix_columns(mix_col_le);
    spawn aes_sub_bytes(sub_bytes_le);
    spawn aes_mix_columns(key_mix_le);

    reg cipher_state : logic[4][4][8];
    reg key : logic[8][32];
    reg dec_key : logic[8][32];
    reg cycle_count : logic[32];

    loop{
        set cycle_count := *cycle_count + 32'd1
    }

    loop{
            try key_gen = recv ep.dec_key_gen_req  {
                //Cycle 0 (Initialization)
                let key_init = recv ep.key_pack >>
                let key_len = recv ep.key_len_i >>
                send key_ri.init(init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}) >>
                set key := key_init >>
                //Cycle 1 - 10 Rounds

                generate_seq (i : 0, 9, 1){
                    send key_ri.req(aes_key_expand_in_pack::{key = *key; round = i; ctrl = init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}}) >>
                    let key_out_pack = recv key_ri.res >>
                    set key := key_out_pack.key
                } >>
                //Cycle 11 (Final Round Storing state)
                set dec_key := *key >>
                //Cycle 12 (Output)
                send ep.res(aes_core_out_pack::{state_o = *cipher_state;
                                                    // data_in_mask_o = #{ #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0}};
                                                    // alert_o = 1'd0; //To:Do fix this
                                                    // data_out_clear_o = 1'd0;
                                                    // key_clear_o = 1'd0;
                                                    // prng_reseed_o = 1'd0;
                                                    crypt_o = sp2v_e::SP2V_LOW;
                                                    dec_key_gen_o = sp2v_e::SP2V_HIGH}) >>
                                                    // {call print_encryption_key(*dec_key)} >>
                                                    cycle 1

            }
            else {
                try data_in = recv ep.crypt{
                    let key_init_in = recv ep.key_pack >>
                    let key_len = recv ep.key_len_i >>
                    let ctrl_in = recv ep.ctrl >>

                    send key_ri.init(init_pack::{op = ctrl_in.op_i; key_len = key_len}) >>

                    // -------------Cycle 0 (Initialization)----------------
                    let key_init = match ctrl_in.op_i {
                        ciph_op_e::CIPH_FWD => key_init_in,
                        _ => *dec_key
                    } >>
                    {set cipher_state := data_in;
                    set key := key_init} >>
                    
                    // dprint "[Cycle %d] Initialization" (*cycle_count);


                    //----------------- Cycle 1 Round 0----------------
                    send key_ri.req(aes_key_expand_in_pack::{key = *key; round = 4'd0; ctrl = init_pack::{op = ctrl_in.op_i; key_len = key_len}}) >>
                    let key_out_pack = recv key_ri.res >> 
                    
                    let key_word_lin = *key[0+:4];
                    let key_word = call create_byte_pack(key_word_lin);

                    let key_bytes_normal = call transpose(key_word);
                    let key_bytes = key_bytes_normal; // No key mix for round 0
                {set cipher_state := call add_rk(*cipher_state , key_bytes);
                    set key := key_out_pack.key} >> // do checks on error of the out pack
                    // dprint "[Cycle %d] Round 0" (*cycle_count);
                    // call print_cipher_state(*cipher_state) >>

                    // -------------Cycle 2-10 (Rounds)----------------
                    generate_seq (i : 1, 9,1){
                        // Key Gen
                        send key_ri.req(aes_key_expand_in_pack::{key = *key; round = i; ctrl = init_pack::{op = ctrl_in.op_i; key_len = key_len}}) >>
                        let key_out_pack = recv key_ri.res >>
                        let key_out = key_out_pack.key; // do checks on error of the out pack

                        // Sub Bytes
                        send sub_bytes_ri.req(data_in_pack::{data = *cipher_state; op = ctrl_in.op_i}) >>
                        let sub_bytes_out = recv sub_bytes_ri.res >>
                        // dprint "[Cycle %d] Round %d : sub_bytes_out[row 0]: %h, %h, %h, %h" (*cycle_count, i, sub_bytes_out[0][0], sub_bytes_out[0][1], sub_bytes_out[0][2], sub_bytes_out[0][3]) >>
                        
                        // Shift Rows
                        send shift_rows_ri.req(data_in_pack::{data = sub_bytes_out; op = ctrl_in.op_i}) >>
                        let shift_rows_out = recv shift_rows_ri.res >>
            
                        // Mix Columns
                        send mix_col_ri.req(data_in_pack::{data = shift_rows_out; op = ctrl_in.op_i}) >>


                        let mix_col_out : logic[4][4][8] = recv mix_col_ri.res >>
                        // dprint "[Cycle %d] Round %d : mix_col_out[row 0]: %h, %h, %h, %h" (*cycle_count, i,mix_col_out[0][0], mix_col_out[0][1], mix_col_out[0][2], mix_col_out[0][3]) >>


                        // Add Round Key
                        let key_word_lin= *key[0+:4];
                        let key_word = call create_byte_pack(key_word_lin);
                        let key_bytes_normal = call transpose(key_word);
                        let key_bytes = match ctrl_in.op_i{
                            ciph_op_e::CIPH_FWD => key_bytes_normal ,
                            _ => (
                                send key_mix_ri.req(data_in_pack::{data = key_bytes_normal; op = ciph_op_e::CIPH_INV}) >>
                                let key_bytes_t = recv key_mix_ri.res >>
                                key_bytes_t
                            )
                        } >>
                        let add_rk_out = call add_rk(mix_col_out,key_bytes);
                        set cipher_state := add_rk_out;
                        set key := key_out
                    }>>

                    // -------------Cycle 11 (Final Round)----------------

                    //Sub Bytes
                    send sub_bytes_ri.req(data_in_pack::{data = *cipher_state; op = ctrl_in.op_i}) >>
                    let sub_bytes_out = recv sub_bytes_ri.res >>


                    //Shift Rows
                    send shift_rows_ri.req(data_in_pack::{data = sub_bytes_out; op = ctrl_in.op_i}) >>
                    let shift_rows_out = recv shift_rows_ri.res >>

                    //Add Round Key
                    let key_word_lin = *key[0+:4] >>
                    let key_word = call create_byte_pack(key_word_lin) >>
                    let key_bytes_normal = call transpose(key_word) >>
                    let key_bytes = match ctrl_in.op_i{
                        ciph_op_e::CIPH_FWD => key_bytes_normal,
                        _ => (
                            send key_mix_ri.req(data_in_pack::{data = key_bytes_normal; op = ciph_op_e::CIPH_INV}) >>
                            let key_bytes = recv key_mix_ri.res >>
                            key_bytes
                        )
                    } >>
                    set cipher_state := call add_rk(shift_rows_out,key_bytes) >>

                    // -------------Cycle 12 (Output)----------------
                    send ep.res(aes_core_out_pack::{state_o = *cipher_state;
                                                    // data_in_mask_o = #{ #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0},
                                                    //                     #{8'd0, 8'd0,8'd0, 8'd0}};
                                                    // alert_o = 1'd0; //To:Do fix this
                                                    // data_out_clear_o = ctrl_in.data_out_clear_i;
                                                    // key_clear_o = ctrl_in.key_clear_i;
                                                    // prng_reseed_o = ctrl_in.prng_reseed_i;
                                                    dec_key_gen_o = sp2v_e::SP2V_LOW;
                                                    crypt_o = sp2v_e::SP2V_HIGH}) >>
                    cycle 1
                }
                else {
                    cycle 1
                }
            }

    }

    loop {
        send entr_ep.req(1'd1) >>
        let entropy = recv entr_ep.res >>
        cycle 1
    }

}
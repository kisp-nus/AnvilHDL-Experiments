
import "aes_pkg.anvilh"
import "aes_key_expand.anvil"
import "aes_shift_rows.anvil"
import "aes_mix_columns.anvil"
import "aes_sub_bytes.anvil"

// func print_encryption_key(key : logic[8][32]){
//         dprint "[Cycle %d] [Enc Key Row 0] %h, %h, %h, %h" (*cycle_count ,key[0][24+:8], key[0][16+:8], key[0][8+:8], key[0][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 1] %h, %h, %h, %h" (*cycle_count ,key[1][24+:8], key[1][16+:8], key[1][8+:8], key[1][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 2] %h, %h, %h, %h" (*cycle_count ,key[2][24+:8], key[2][16+:8], key[2][8+:8], key[2][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 3] %h, %h, %h, %h" (*cycle_count ,key[3][24+:8], key[3][16+:8], key[3][8+:8], key[3][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 4] %h, %h, %h, %h" (*cycle_count ,key[4][24+:8], key[4][16+:8], key[4][8+:8], key[4][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 5] %h, %h, %h, %h" (*cycle_count ,key[5][24+:8], key[5][16+:8], key[5][8+:8], key[5][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 6] %h, %h, %h, %h" (*cycle_count ,key[6][24+:8], key[6][16+:8], key[6][8+:8], key[6][0+:8]) >>
//         dprint "[Cycle %d] [Enc Key Row 7] %h, %h, %h, %h" (*cycle_count ,key[7][24+:8], key[7][16+:8], key[7][8+:8], key[7][0+:8])
// }
// func print_decryption_key(key : logic[8][32]){
//         generate(i : 0, 7, 1){
//             dprint "[Cycle %d] [Dec Key Row %d] %h, %h, %h, %h" (*cycle_count, i, key[i][24+:8], key[i][16+:8], key[i][8+:8], key[i][0+:8])
//         }
// }


// func print_cipher_state(cipher_state : logic[4][4][8]){
//     generate(i : 0, 3, 1){
//         dprint "[Cycle %d] [Cipher State Row %d] %h, %h, %h, %h" (*cycle_count, i, cipher_state[i][3], cipher_state[i][2], cipher_state[i][1], cipher_state[i][0])
//     }   
// }

enum state_e {
    INIT,
    KEY_GEN,
    ENCRYPT
}
func KEY_GEN (){
    let key_len = recv ep.key_len_i  >>
    let i = *round >>
    let last_round = match key_len{
        key_len_e::KEY_LEN_128 => 4'd9,
        key_len_e::KEY_LEN_256 => 4'd13,
        _ => 4'd1
    } >>
    if ((key_len == key_len_e::KEY_LEN_256)&&(i == 4'd0)){
        set round := 4'd1
    }
    else if (i < last_round){
        send key_ri.req(aes_key_expand_in_pack::{key = *dec_key; round = i; ctrl = init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}}) >>
        let key_out_pack = recv key_ri.res >>
        set dec_key := key_out_pack.key;
        set round := *round + 4'd1
    }
    else if (i == last_round){
        send key_ri.req(aes_key_expand_in_pack::{key = *dec_key; round = i; ctrl = init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}}) >>
        let key_out_pack = recv key_ri.res >>
        set dec_key := key_out_pack.key;
       { 
        send ep.dec_key_gen_res(1'd1) >> // Maybe send error alert
        set round := 4'd0;
        set state := state_e::INIT
       }
    }
    else{
        set state := state_e::INIT
    }

}

func ROUND_0(){
    let key_len = recv ep.key_len_i >>
    let c = recv ep.ctrl >>
    let op = c.op_i  >>

    let key_word_lin = match key_len{
                                key_len_e::KEY_LEN_128 => *key[0+:4],
                                key_len_e::KEY_LEN_256 => {
                                    match op {
                                        ciph_op_e::CIPH_FWD => *key[0+:4],
                                        _ => *key[4+:4]
                                    }
                                },
                                _ => {
                                    *key[0+:4]
                                }
    } >>

    let key_word = call create_byte_pack(key_word_lin) >>
                            let key_bytes_normal = call transpose(key_word) >>
                            let key_bytes = key_bytes_normal >>
    let add_rk = call add_rk(*cipher_state , key_bytes) >>
    set cipher_state := add_rk;
                            
    {
        match key_len {
                    key_len_e::KEY_LEN_128 =>{
                        send key_ri.req(aes_key_expand_in_pack::{key = *key; round = 4'd0; ctrl = init_pack::{op = op; key_len = key_len}}) >>
                        let key_out_pack = recv key_ri.res >>
                        set key := key_out_pack.key;
                        set round := *round+4'd1
                        
                    },
                    key_len_e::KEY_LEN_256 =>{
                            
                            set round := *round+4'd1
                    },
                    _ => {
                            dprint "Unsupported key length" () >>
                            set state := state_e::INIT
                    }
        }
    }
}

func ROUND_NORMAL(i){
    let key_len = recv ep.key_len_i  >>
    let c = recv ep.ctrl >>
    let op = c.op_i  >>

    send key_ri.req(aes_key_expand_in_pack::{key = *key; round = i; ctrl = init_pack::{op = op; key_len = key_len}}) >>
    let key_out_pack = recv key_ri.res >>
    let key_out = key_out_pack.key >>

    // Sub Bytes
    send sub_bytes_ri.req(data_in_pack::{data = *cipher_state; op = op}) >>
    let sub_bytes_out = recv sub_bytes_ri.res >>

    // Shift Rows
    send shift_rows_ri.req(data_in_pack::{data = sub_bytes_out; op = op}) >>
    let shift_rows_out = recv shift_rows_ri.res >>
                    
    // Mix Columns
    send mix_col_ri.req(data_in_pack::{data = shift_rows_out; op = op}) >>
    let mix_col_out : logic[4][4][8] = recv mix_col_ri.res >>
                                
    // Add Round Key
    let key_word_lin= match key_len{
                key_len_e::KEY_LEN_128 => *key[0+:4],
                key_len_e::KEY_LEN_256 => {
                    match op {
                            ciph_op_e::CIPH_FWD => *key[4+:4],
                            _ => *key[0+:4]
                    }
                },
                _ => {
                        *key[0+:4]
                }
    } >>
    let key_word = call create_byte_pack(key_word_lin);
    let key_bytes_normal = call transpose(key_word);
    let key_bytes = match op{
            ciph_op_e::CIPH_FWD => key_bytes_normal ,
            ciph_op_e::CIPH_INV => {
                    send key_mix_ri.req(data_in_pack::{data = key_bytes_normal; op = ciph_op_e::CIPH_INV}) >>
                    let key_bytes_t = recv key_mix_ri.res >>
                    key_bytes_t
            },
            _ => {
                    dprint "Invalid operation" ();
                    key_bytes_normal
            }
    } >>
    let add_rk_out = call add_rk(mix_col_out,key_bytes) >>
    set cipher_state := add_rk_out;
    set key := key_out;
    set round := *round + 4'd1
}

func ROUND_FINISH(){
    let c = recv ep.ctrl >>
    let op = c.op_i >>
    let key_len = recv ep.key_len_i >>
    send sub_bytes_ri.req(data_in_pack::{data = *cipher_state; op = op}) >>
    let sub_bytes_out = recv sub_bytes_ri.res >>

    //Shift Rows
    send shift_rows_ri.req(data_in_pack::{data = sub_bytes_out; op = op}) >>
    let shift_rows_out = recv shift_rows_ri.res >>

    //Add Round Key
    let key_word_lin = match key_len{
            key_len_e::KEY_LEN_128 => *key[0+:4],
            key_len_e::KEY_LEN_256 => {
                    match op {
                                ciph_op_e::CIPH_FWD => *key[4+:4],
                                _ => *key[0+:4]
                    }
            },
            _ => {
                    *key[0+:4]
            }
    } >>                                            
    let key_word = call create_byte_pack(key_word_lin) >>
    let key_bytes_normal = call transpose(key_word) >>
    let key_bytes = key_bytes_normal >>
    let add_rk_out = call add_rk(shift_rows_out,key_bytes) >>

    let null = #{
        #{8'd0, 8'd0,8'd0, 8'd0},
         #{8'd0, 8'd0,8'd0, 8'd0},
         #{8'd0, 8'd0,8'd0, 8'd0},
         #{8'd0, 8'd0,8'd0, 8'd0}
    } >>

    send ep.crypt_res(aes_core_out_pack::{state_o = add_rk_out;
                                        data_in_mask_o = null;
                                        alert_o = 1'd0; //To:Do fix this
                                        // data_out_clear_o = 1'd0;
                                        // key_clear_o = 1'd0;
                                        prng_reseed_o = 1'd0 }) >>
    set cipher_state := add_rk_out;
    set state := state_e::INIT
}
func ENCRYPT(){
    let key_len = recv ep.key_len_i  >>
    let i = *round >>
    let last_round = match key_len{
        key_len_e::KEY_LEN_128 => 4'd10,
        key_len_e::KEY_LEN_256 => 4'd14,
        _ => 4'd1
    } >>
    if(i == 4'd0){
        call ROUND_0()
    }
    else if (i < last_round){
        call ROUND_NORMAL(i)
    }
    else{
        call ROUND_FINISH() 
    }
}


func INIT(){
    try key_gen = recv ep.dec_key_gen_req  {
        let key_init = recv ep.key_pack >>
        let key_len = recv ep.key_len_i >>
        send key_ri.init(init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}) >>
        set dec_key := key_init ; 
        set round := 4'd0;
        set state := state_e::KEY_GEN
    }
    else {
        try data_in = recv ep.crypt{
                let key_init_in = recv ep.key_pack >>
                let key_len = recv ep.key_len_i >>
                let ctrl_in = recv ep.ctrl >>
                send key_ri.init(init_pack::{op = ctrl_in.op_i; key_len = key_len}) >>
                let key_init = match ctrl_in.op_i {
                            ciph_op_e::CIPH_FWD => key_init_in,
                            _ => *dec_key
                } >>
                set cipher_state := data_in;
                set key := key_init;
                set state := state_e::ENCRYPT;
                set round := 4'd0
        }
        else{
            set round := 4'd0
        }
            
    }


}



proc aes_cipher_core(ep : left aes_core_ch, entr_ep : right entropy_ch<1>){
    chan key_le -- key_ri : aes_key_expand_ch;
    chan shift_rows_le -- shift_rows_ri : shift_rows_ch;
    chan mix_col_le -- mix_col_ri : mix_column_ch;
    chan key_mix_le -- key_mix_ri : mix_column_ch;
    chan sub_bytes_le -- sub_bytes_ri : sub_bytes_ch;
    spawn aes_key_expand(key_le);
    spawn aes_shift_rows(shift_rows_le);
    spawn aes_mix_columns(mix_col_le);
    spawn aes_sub_bytes(sub_bytes_le);
    spawn aes_mix_columns(key_mix_le);

    reg cipher_state : logic[4][4][8];
    reg key : logic[8][32];
    reg dec_key : logic[8][32];
    reg state : state_e;
    reg round : logic[4];
    reg key_len_r : key_len_e;
    reg op_r : ciph_op_e;

    loop {
        try prd_state = recv ep.data_out_clear_i{
            set cipher_state := prd_state >>
            send ep.data_out_clear_o(1'd1) >>
            send ep.key_clear_o(1'd0) >>
            set state := state_e::INIT
        }
        else try kd = recv ep.key_clear_i{
            let key_state = recv ep.key_pack >>
            let key_len = recv ep.key_len_i >>
            send key_ri.init(init_pack::{op = ciph_op_e::CIPH_FWD; key_len = key_len}) >>
            {set key := kd;
            set dec_key := kd }  >>
            send ep.key_clear_o(1'd1) >>
            send ep.data_out_clear_o(1'd0) >>
            set state := state_e::INIT
        }
        else{
            send ep.key_clear_o(1'd0) >>
            send ep.data_out_clear_o(1'd0) >>
            match *state{
                state_e::KEY_GEN => call KEY_GEN(),
                state_e::ENCRYPT => call ENCRYPT(),
                _ => call INIT()
            }
        }
    }

}
import "aes_pkg.anvilh"



func use_sbox(data_in: data_in_pack){
    // generate(i : 0, 3, 1){
    //     generate(j : 0, 3, 1){
    //         send sri.req(data_in[i][j]) >>
    //         let data_out = recv sli.res >>
    //     }
    // } To do : make this more convenient
    let d00 = sbox_in::{data = data_in.data[0][0]; op = data_in.op};
    send sri_0_0.req(d00) >>
    
    let data_o_0_0 = recv sri_0_0.res >>
    let d01 = sbox_in::{data = data_in.data[0][1]; op = data_in.op};
    send sri_0_1.req(d01) >>
    let data_o_0_1 = recv sri_0_1.res >>
    let d02 = sbox_in::{data = data_in.data[0][2]; op = data_in.op};
    send sri_0_2.req(d02) >>
    let data_o_0_2 = recv sri_0_2.res >>
    let d03 = sbox_in::{data = data_in.data[0][3]; op = data_in.op};
    send sri_0_3.req(d03) >>
    let data_o_0_3 = recv sri_0_3.res >>

    let d10 = sbox_in::{data = data_in.data[1][0]; op = data_in.op};
    send sri_1_0.req(d10) >>
    let data_o_1_0 = recv sri_1_0.res >>

    let d11 = sbox_in::{data = data_in.data[1][1]; op = data_in.op};
    send sri_1_1.req(d11) >>
    let data_o_1_1 = recv sri_1_1.res >>
    let d12 = sbox_in::{data = data_in.data[1][2]; op = data_in.op};
    send sri_1_2.req(d12) >>
    let data_o_1_2 = recv sri_1_2.res >>
    let d13 = sbox_in::{data = data_in.data[1][3]; op = data_in.op};
    send sri_1_3.req(d13) >>
    let data_o_1_3 = recv sri_1_3.res >>

    let d20 = sbox_in::{data = data_in.data[2][0]; op = data_in.op};
    send sri_2_0.req(d20) >>
    let data_o_2_0 = recv sri_2_0.res >>

    let d21 = sbox_in::{data = data_in.data[2][1]; op = data_in.op};
    send sri_2_1.req(d21) >>
    let data_o_2_1 = recv sri_2_1.res >>

    let d22 = sbox_in::{data = data_in.data[2][2]; op = data_in.op};
    send sri_2_2.req(d22) >>
    let data_o_2_2 = recv sri_2_2.res >>

    let d23 = sbox_in::{data = data_in.data[2][3]; op = data_in.op};
    send sri_2_3.req(d23) >>
    let data_o_2_3 = recv sri_2_3.res >>

    let d30 = sbox_in::{data = data_in.data[3][0]; op = data_in.op};
    send sri_3_0.req(d30) >>
    let data_o_3_0 = recv sri_3_0.res >>

    let d31 = sbox_in::{data = data_in.data[3][1]; op = data_in.op};
    send sri_3_1.req(d31) >>
    let data_o_3_1 = recv sri_3_1.res >>
    let d32 = sbox_in::{data = data_in.data[3][2]; op = data_in.op};
    send sri_3_2.req(d32) >>
    let data_o_3_2 = recv sri_3_2.res >>
    let d33 = sbox_in::{data = data_in.data[3][3]; op = data_in.op};
    send sri_3_3.req(d33) >>
    let data_o_3_3 = recv sri_3_3.res >>

    #{ 
        #{data_o_3_3, data_o_3_2, data_o_3_1, data_o_3_0},
        #{data_o_2_3, data_o_2_2, data_o_2_1, data_o_2_0},
        #{data_o_1_3, data_o_1_2, data_o_1_1, data_o_1_0},
        #{data_o_0_3, data_o_0_2, data_o_0_1, data_o_0_0}
    }//check this orientation
}   

proc aes_sub_bytes(ep : left sub_bytes_ch){
    chan sli_0_0 -- sri_0_0 : sbox_ch;
    spawn sbox(sli_0_0);
    chan sli_0_1 -- sri_0_1 : sbox_ch;
    spawn sbox(sli_0_1);
    chan sli_0_2 -- sri_0_2 : sbox_ch;
    spawn sbox(sli_0_2);
    chan sli_0_3 -- sri_0_3 : sbox_ch;
    spawn sbox(sli_0_3);

    chan sli_1_0 -- sri_1_0 : sbox_ch;
    spawn sbox(sli_1_0);
    chan sli_1_1 -- sri_1_1 : sbox_ch;
    spawn sbox(sli_1_1);
    chan sli_1_2 -- sri_1_2 : sbox_ch;
    spawn sbox(sli_1_2);
    chan sli_1_3 -- sri_1_3 : sbox_ch;
    spawn sbox(sli_1_3);

    chan sli_2_0 -- sri_2_0 : sbox_ch;
    spawn sbox(sli_2_0);
    chan sli_2_1 -- sri_2_1 : sbox_ch;
    spawn sbox(sli_2_1);
    chan sli_2_2 -- sri_2_2 : sbox_ch;
    spawn sbox(sli_2_2);
    chan sli_2_3 -- sri_2_3 : sbox_ch;
    spawn sbox(sli_2_3);

    chan sli_3_0 -- sri_3_0 : sbox_ch;
    spawn sbox(sli_3_0);
    chan sli_3_1 -- sri_3_1 : sbox_ch;
    spawn sbox(sli_3_1);
    chan sli_3_2 -- sri_3_2 : sbox_ch;
    spawn sbox(sli_3_2);
    chan sli_3_3 -- sri_3_3 : sbox_ch;
    spawn sbox(sli_3_3);
    // reg cycle_count : logic[32];
    // loop{
    //     set cycle_count := *cycle_count + 32'd1
    // }
    loop{
        try data_in = recv ep.req{
            let data_out = call use_sbox(data_in)>>
            send ep.res(data_out)
        } >>
        cycle 1
    }
}

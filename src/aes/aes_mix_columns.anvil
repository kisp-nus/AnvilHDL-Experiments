import "aes_pkg.anvilh"

struct mix_column_in_pack{
    data : logic[4][8],
    op : ciph_op_e
}
chan mix_single_column_ch {
    left req : (mix_column_in_pack@eternal) @#1 - @#1,
    right res : (logic[4][8]@eternal) @#1 - @#1
}

proc mix_single_columns(ep : left mix_single_column_ch){
    loop {
        let inp = recv ep.req >>
        let data : logic[4][8] = inp.data >>
        let op_i : ciph_op_e = inp.op >>

        let x0 : logic[8] = data[0]^data[3] >>
        let x1 : logic[8] = data[3]^data[2] >>
        let x2 : logic[8] = data[2]^data[1] >>
        let x3 : logic[8] = data[1]^data[0] >>

        let x_mult2_0 : logic[8] = call mul2(x0) >>
        let x_mult2_1 : logic[8] = call mul2(x1) >>
        let x_mult2_2 : logic[8] = call mul2(x2) >>
        let x_mult2_3 : logic[8] = call mul2(x3) >>

        let y_pre_0 : logic[8] = (data[3])^(data[1]) >>
        let y_pre_1 : logic[8] = (data[2])^(data[0]) >>

        let y_0 : logic[8] = call mul4(y_pre_0) >>
        let y_1 : logic[8] = call mul4(y_pre_1) >>


        let y2_pre : logic[8] = y_0^y_1 >>
        let y2 : logic[8] = call mul2(y2_pre) >>


        let z_0 : logic[8] = y2^y_0 >>
        let z_1 : logic[8] = y2^y_1 >>

        let z_muxed_0 : logic[8] = match op_i {
            ciph_op_e::CIPH_FWD => 8'd0,
            ciph_op_e::CIPH_INV => z_0,
            _ => 8'd0
        } >>

        let z_muxed_1 : logic[8] = match op_i {
            ciph_op_e::CIPH_FWD => 8'd0,
            ciph_op_e::CIPH_INV => z_1,
            _ => 8'd0
        } >>

        let data_o_1 : logic[8] = data[1]^(x_mult2_3)^(x1)^(z_muxed_1) >>
        let data_o_2 : logic[8] = data[0]^(x_mult2_2)^(x1)^(z_muxed_0) >>
        let data_o_3 : logic[8] = data[3]^(x_mult2_1)^(x3)^(z_muxed_1) >>
        let data_o_4 : logic[8] = data[2]^(x_mult2_0)^(x3)^(z_muxed_0) >>

        let data_out : logic[4][8] = #{data_o_4, data_o_3, data_o_2, data_o_1} >>
        send ep.res(data_out) >>
        cycle 1
    }

}

proc aes_mix_columns (ep : left mix_column_ch) {
    chan mcle0 -- mcri0 : mix_single_column_ch ;
    spawn mix_single_columns(mcle0) ;
    chan mcle1 -- mcri1 : mix_single_column_ch ;
    spawn mix_single_columns(mcle1) ;
    chan mcle2 -- mcri2 : mix_single_column_ch ;
    spawn mix_single_columns(mcle2) ;
    chan mcle3 -- mcri3 : mix_single_column_ch ;
    spawn mix_single_columns(mcle3) ;

    loop{
            let data_in : data_in_pack = recv ep.req >>
            let data_i_transposed : logic[4][4][8] = call transpose(data_in.data) >>
            {
                send mcri0.req(mix_column_in_pack::{data = data_i_transposed[0]; op = data_in.op}) >>
                send mcri1.req(mix_column_in_pack::{data = data_i_transposed[1]; op = data_in.op}) >>
                send mcri2.req(mix_column_in_pack::{data = data_i_transposed[2]; op = data_in.op}) >>
                send mcri3.req(mix_column_in_pack::{data = data_i_transposed[3]; op = data_in.op}) 
            }
            >>
            let row_1 : logic[4][8]= recv mcri0.res >>
            let row_2 : logic[4][8] = recv mcri1.res >>
            let row_3 : logic[4][8] = recv mcri2.res >>
            let row_4 : logic[4][8] = recv mcri3.res >>


            
            let data_out : logic[4][4][8] = #{row_4, row_3, row_2, row_1} >>
            let data_out_transposed : logic[4][4][8] = call transpose(data_out) >>
            send ep.res(data_out_transposed) >>
            cycle 1
    }
}
import "aes_cipher_core.anvil"

func print_state(state : logic[4][4][8]) {
   generate(i : 0, 3, 1){
        dprint "[Row %d] %h, %h, %h, %h" (i, state[i][0], state[i][1], state[i][2], state[i][3])
   }
   
}
proc aes_cipher_core_tb(){
    chan ep_le -- ep_ri : aes_core_ch;
    chan entr_ep_le -- entr_ep_ri : entropy_ch<128>;
    spawn aes_cipher_core(ep_le, entr_ep_ri);
    reg counter : logic[32];
    reg next_inp : logic[4][4][8];
    reg next_key : logic[8][32];
    loop{
        set counter := *counter + 32'd1
    }
    loop{
        dprint "[cycle %d] Sending request to aeS core"  (*counter);
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                };
        let inp = #{
                    #{8'h01, 8'h02, 8'h03, 8'h04},
                    #{8'h05, 8'h06, 8'h07, 8'h08},
                    #{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #{8'h0d, 8'h0e, 8'h0f, 8'h10}
                };

        send ep_ri.crypt(inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_FWD
        }) >>
        let cipher_text = recv ep_ri.res >>
        
        dprint "[cycle %d] Received response from AES core encryption test" (*counter);

        call print_state(cipher_text.state_o);

        set next_inp := cipher_text.state_o >>
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                };

        send ep_ri.dec_key_gen_req(1'd1) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>


        let _ = recv ep_ri.res >>
        // dprint "[cycle %d] Received response from AES core decryption key req" (*counter);

        cycle 1 >>

        send ep_ri.crypt(*next_inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_INV
        }) >>

        let dec_cipher_text = recv ep_ri.res >>
        call print_state(dec_cipher_text.state_o)>>

        cycle 10 >>
        

       dfinish >>
        cycle 1
    }
}
import "aes_cipher_core.anvil"

func print_state(state : logic[4][4][8]) {
   generate(i : 0, 3, 1){
        dprint "[Row %d] %h, %h, %h, %h" (i, state[i][3], state[i][2], state[i][1], state[i][0])
   }
   
}

func print_enc_key(key : logic[8][32]) {
   generate(i : 0, 7, 1){
        dprint "[Row %d] %h, %h, %h, %h" (i, key[i][24+:8], key[i][16+:8], key[i][8+:8], key[i][0+:8])
   }
}
proc aes_cipher_core_tb(){
    chan ep_le -- ep_ri : aes_core_ch;
    chan entr_ep_le -- entr_ep_ri : entropy_ch<1>;
    spawn aes_cipher_core(ep_le, entr_ep_ri);
    reg counter : logic[32];
    reg next_inp : logic[4][4][8];
    reg next_key : logic[8][32];
    loop{
        set counter := *counter + 32'd1
    }
    loop{
        cycle 100 >>
        let prd_clearing_state_i = #{
                #{8'd0, 8'd0, 8'd0, 8'd0},
                #{8'd0, 8'd0, 8'd0, 8'd0},
                #{8'd0, 8'd0, 8'd0, 8'd0},
                #{8'd0, 8'd0, 8'd0, 8'd0}
            } >>
        let prd_clearing_key_i = #{
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0},
                #flat{8'd0, 8'd0, 8'd0, 8'd0}
            } >>
        send ep_ri.data_out_clear_i(prd_clearing_state_i) >>
        send ep_ri.key_clear_i(prd_clearing_key_i) >>
        cycle 1
    }
    loop{
        dprint "==============[cycle %d] Sending AES_128 request to aeS core==============="  (*counter) >>
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                } >>
        let inp = #{
                    #{8'h0d, 8'h0e, 8'h0f, 8'h10},
                    #{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #{8'h05, 8'h06, 8'h07, 8'h08},
                    #{8'h01, 8'h02, 8'h03, 8'h04}
                } >>

        call print_state(inp) >>

        send ep_ri.crypt(inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_FWD;
            prng_reseed_i = 1'd0;
            // key_clear_i = 1'd0;
            // data_out_clear_i = 1'd0;
            alert_fatal_i = 1'd0;
            force_masks_i = 1'd0
        }) >>
        
        let cipher_text = recv ep_ri.crypt_res >>
        dprint "======================[cycle %d] Received response from AES core encryption test for AES 128==============" (*counter) >>

        call print_state(cipher_text.state_o) >>

        set next_inp := cipher_text.state_o >>
        
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                } >>

        send ep_ri.dec_key_gen_req(1'd1) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>

        


        let _ = recv ep_ri.dec_key_gen_res >>
        dprint "[cycle %d] Decryption Key is generated" (*counter) >>

        cycle 1 >>


        dprint "================[cycle %d] Sending request to AES core for decryption=======" (*counter) >>

        send ep_ri.crypt(*next_inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_128) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_INV;
            prng_reseed_i = 1'd0;
            // key_clear_i = 1'd0;
            // data_out_clear_i = 1'd0;
            alert_fatal_i = 1'd0;
            force_masks_i = 1'd0
        }) >>

        
        let dec_cipher_text = recv ep_ri.crypt_res >>
        dprint "================[cycle %d] Received response from AES core decryption test for AES 128=======" (*counter) >>
        call print_state(dec_cipher_text.state_o) >>
        

        cycle 5 >>


        dprint "==============[cycle %d] Sending AES_256 request to aeS core==============="  (*counter) >>
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                } >>
        let inp = #{
                    #{8'h0d, 8'h0e, 8'h0f, 8'h10},
                    #{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #{8'h05, 8'h06, 8'h07, 8'h08},
                    #{8'h01, 8'h02, 8'h03, 8'h04}
                } >>

        call print_state(inp) >>

        send ep_ri.crypt(inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_256) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_FWD;
            prng_reseed_i = 1'd0;
            // key_clear_i = 1'd0;
            // data_out_clear_i = 1'd0;
            alert_fatal_i = 1'd0;
            // prd_clearing_state_i = #{
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0}
            // };
            // prd_clearing_key_i = #{
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0}
            // };
            force_masks_i = 1'd0
        }) >>
        
        let cipher_text = recv ep_ri.crypt_res >>
        dprint "======================[cycle %d] Received response from AES core encryption test for AES 256==============" (*counter) >>

        call print_state(cipher_text.state_o) >>

        set next_inp := cipher_text.state_o >>
        
        let key = #{
                    #flat{8'h01, 8'h02, 8'h03, 8'h04},
                    #flat{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #flat{8'h11, 8'h12, 8'h13, 8'h14},
                    #flat{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #flat{8'h21, 8'h22, 8'h23, 8'h24},
                    #flat{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #flat{8'h31, 8'h32, 8'h33, 8'h34},
                    #flat{8'h39, 8'h3a, 8'h3b, 8'h3c}
                } >>

        send ep_ri.dec_key_gen_req(1'd1) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_256) >>

        


        let _ = recv ep_ri.dec_key_gen_res >>
        
        
        dprint "[cycle %d] Decryption Key is generated" (*counter) >>

        cycle 1 >>


        dprint "================[cycle %d] Sending request to AES core for decryption=======" (*counter) >>

        send ep_ri.crypt(*next_inp) >>
        send ep_ri.key_pack(key) >>
        send ep_ri.key_len_i(key_len_e::KEY_LEN_256) >>
        send ep_ri.ctrl(aes_control_pack::{
            cfg_valid_i = 1'd1;
            op_i = ciph_op_e::CIPH_INV;
            prng_reseed_i = 1'd0;
            // key_clear_i = 1'd0;
            // data_out_clear_i = 1'd0;
            alert_fatal_i = 1'd0;
            // prd_clearing_state_i = #{
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0},
            //     #{8'd0, 8'd0, 8'd0, 8'd0}
            // };
            // prd_clearing_key_i = #{
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0},
            //     #flat{8'd0, 8'd0, 8'd0, 8'd0}
            // };
            force_masks_i = 1'd0
        }) >>


        let dec_cipher_text = recv ep_ri.crypt_res >>
        dprint "================[cycle %d] Received response from AES core decryption test for AES 256=======" (*counter) >>
        call print_state(dec_cipher_text.state_o) >>
        

       dfinish >>
        cycle 1
    }
}
import "aes_key_expand.anvil"
func print_enc_key(key_pack : logic[8][32]) {
    generate(i : 0, 7, 1){
        dprint "[KETB Key Row %d] %h, %h, %h, %h" (i,key_pack[i][24+:8], key_pack[i][16+:8], key_pack[i][8+:8], key_pack[i][0+:8])
    }
}
proc aes_key_expand_tb(){
    chan ep_le -- ep_ri : aes_key_expand_ch;
    spawn aes_key_expand(ep_le);
    reg counter : logic[32];
    reg next_inp : logic[4][4][8];
    reg next_key : logic[8][32];
    loop{
        set counter := *counter + 32'd1
    }
    loop{
        dprint "[cycle %d] Sending request to AES key expansion" (*counter);
        send ep_ri.init(init_pack::{key_len = key_len_e::KEY_LEN_128; op = ciph_op_e::CIPH_FWD}) >>
        
        set next_key := #{
                    #{8'h01, 8'h02, 8'h03, 8'h04},
                    #{8'h09, 8'h0a, 8'h0b, 8'h0c},
                    #{8'h11, 8'h12, 8'h13, 8'h14},
                    #{8'h19, 8'h1a, 8'h1b, 8'h1c},
                    #{8'h21, 8'h22, 8'h23, 8'h24},
                    #{8'h29, 8'h2a, 8'h2b, 8'h2c},
                    #{8'h31, 8'h32, 8'h33, 8'h34},
                    #{8'h39, 8'h3a, 8'h3b, 8'h3c}
        }>>
        send ep_ri.req(aes_key_expand_in_pack::{
            key = *next_key;
            round = 4'd0;
            ctrl = init_pack::{key_len = key_len_e::KEY_LEN_128; op = ciph_op_e::CIPH_FWD}
        }) >>
        let key_out = recv ep_ri.res >>
        dprint "[cycle %d] Received response from AES key expansion test" (*counter);
        call print_enc_key(key_out.key) >>
        cycle 1 >>
        dfinish
        

    }
}
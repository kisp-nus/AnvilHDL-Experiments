import "aes_pkg.anvilh"

// func print_encryption_key(key_pack : logic[8][32]) {
//     generate(i : 0, 7, 1){
//         dprint "[KE Key Row %d] %h, %h, %h, %h" (i,key_pack[i][24+:8], key_pack[i][16+:8], key_pack[i][8+:8], key_pack[i][0+:8])
//     }
// }

func aes_sub_word(data_in : logic[32]) {
    
    let b0 = sbox_in::{data=data_in[0+:8]; op = ciph_op_e::CIPH_FWD} >>
    let b1 = sbox_in::{data=data_in[8+:8]; op = ciph_op_e::CIPH_FWD} >>
    let b2 = sbox_in::{data=data_in[16+:8]; op = ciph_op_e::CIPH_FWD} >>
    let b3 = sbox_in::{data=data_in[24+:8]; op = ciph_op_e::CIPH_FWD} >>


    // dprint "sbox_in: %h, %h, %h, %h" (b0.data, b1.data, b2.data, b3.data) >>



    send sch0_ri.req(b0) >>
    let b0_o = recv sch0_ri.res >>
    send sch1_ri.req(b1) >>
    let b1_o = recv sch1_ri.res >>
    send sch2_ri.req(b2) >>
    let b2_o = recv sch2_ri.res >>
    send sch3_ri.req(b3) >>
    let b3_o = recv sch3_ri.res >>
    // dprint "sbox_out: %h, %h, %h, %h" (b0_o, b1_o, b2_o, b3_o) >>
    #flat{b3_o, b2_o, b1_o, b0_o}
}

func expand_key(data_in : aes_key_expand_in_pack) {
    let key = data_in.key >>
    let key_len = data_in.ctrl.key_len >>
    
    let op = data_in.ctrl.op >>
    let rnd = data_in.round >>
    let rot_word_out = match key_len {
        key_len_e::KEY_LEN_128 => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    call circ_byte_shift_flat(key[3], 2'h3)
                },
                _ => {
                    call circ_byte_shift_flat(key[3]^key[2], 2'h3)
                }
            }
            
        },
        key_len_e::KEY_LEN_256 => {
            match rnd[0] {
                1'b0 => {
                    match op {
                        ciph_op_e::CIPH_FWD => {
                            key[7]
                        },
                        _ => {
                            key[3]
                        }
                    }
                },
                _ =>{
                    match op {
                        ciph_op_e::CIPH_FWD => {
                            call circ_byte_shift_flat(key[7], 2'h3)
                        },
                        _ => {
                            call circ_byte_shift_flat(key[3], 2'h3)
                        }
                    }
                }
            }
        },
        _ => {
            //ignoring 192 bit key length for now
            key[3]
        }
    } >>
    let sub_word_out = call aes_sub_word(rot_word_out) >>
    
    let use_rcon = match key_len {
        key_len_e::KEY_LEN_256 => {
            match rnd[0] {
                1'b0 => 1'b0,  // For AES-256 even rounds, don't use Rcon
                _ => 1'b1
            }
        },
        _ => 1'b1
    } >>
    
    let rcon_add_out = match use_rcon {
        1'b1 => sub_word_out[0+:8] ^ (*rcon),
        _ => sub_word_out[0+:8]
    } >>
    
    let irregular = match use_rcon {
        1'b1 => #flat{sub_word_out[8+:24], rcon_add_out},
        _ => sub_word_out
    } >>
    let out = match key_len {
        key_len_e::KEY_LEN_128 => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    let w0 = irregular ^ key[0];
                    let w1 = w0 ^ key[1];
                    let w2 = w1 ^ key[2];
                    let w3 = w2 ^ key[3];
                    #{key[3], key[2], key[1], key[0], w3, w2, w1, w0}
                },
                ciph_op_e::CIPH_INV => {
                    let w1 = key[0] ^ key[1];
                    let w2 = key[1] ^ key[2];
                    let w3 = key[2] ^ key[3];
                    // dprint "[Cycle %d] [Round %d] rcon =%h| sub word out = %h | rcon_add_out = %h | rot_word_out = %h" (*counter,rnd,*rcon, sub_word_out,rcon_add_out, rot_word_out) >>
                    #{key[3], key[2], key[1], key[0], w3, w2, w1, irregular ^ key[0]}
                },
                _ => {
                    #{key[3], key[2], key[1], key[0], key[3], key[2], key[1], key[0]}
                }
            }
        },
        key_len_e::KEY_LEN_256 => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    match rnd{
                        4'd0 => {
                            #{key[3], key[2], key[1], key[0], key[7], key[6], key[5], key[4]}
                        },
                        _ => {
                            let w4 = irregular ^ key[0];
                            let w5 = w4 ^ key[1];
                            let w6 = w5 ^ key[2];
                            let w7 = w6 ^ key[3];
                            #{w7, w6, w5, w4, key[7], key[6], key[5], key[4]}
                        }
                    }
                },
                ciph_op_e::CIPH_INV => {
                    match rnd{
                        4'd0 => {
                            #{key[3], key[2], key[1], key[0], key[7], key[6], key[5], key[4]}
                        },
                        _ => {
                            let w0 = irregular ^ key[4] >>
                            let w1 = key[4] ^ key[5] >>
                            let w2 = key[5] ^ key[6] >>
                            let w3 = key[6] ^ key[7] >>
                            #{key[3], key[2], key[1], key[0],w3, w2, w1, w0}
                        }
                    }
                },
                _ => key
            }
        },
        _ => {
            //ignoring 192 bit key length for now
            key
        }
    }>>
    
    // call print_encryption_key(out) >>
    out

}

func set_rcon(data_in, clear_i : logic) {
    let op = data_in.op;
    let key_len = data_in.key_len;
    match clear_i {
        1'd1 => {
            match op{
                ciph_op_e::CIPH_FWD => {
                    set rcon := 8'h01
                },
                _ => {
                    match key_len {
                        key_len_e::KEY_LEN_128 => {
                            set rcon := 8'h36
                        },
                        key_len_e::KEY_LEN_256 => {
                            set rcon := 8'h40
                        },
                        _ => {
                            set rcon := 8'h80
                        }
                    }
                }
            }
        },
        _ => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    set rcon := call mul2(*rcon)
                },
                ciph_op_e::CIPH_INV => {
                    set rcon := call div2(*rcon)
                },
                _ => {
                    set rcon := 8'h01
                }
            }
        }
    }
}

func should_update_rcon(key_len : key_len_e, rnd : logic[4]) {
    match key_len {
        key_len_e::KEY_LEN_256 => {
            match rnd[0] {
                1'b0 => 1'b0,
                _ => 1'b1
            }
        },
        _ => 1'b1
    }
}

 
proc aes_key_expand(ep : left aes_key_expand_ch) {
    chan sch0_le -- sch0_ri : sbox_ch;
    chan sch1_le -- sch1_ri : sbox_ch;
    chan sch2_le -- sch2_ri : sbox_ch;
    chan sch3_le -- sch3_ri : sbox_ch;
    spawn sbox(sch0_le);
    spawn sbox(sch1_le);
    spawn sbox(sch2_le);
    spawn sbox(sch3_le);
    reg rcon : logic[8];
    // reg counter : logic[32];

    // loop{
    //     set counter := *counter + 32'd1
    // }
    loop {
        try init = recv ep.init{
            call set_rcon(init, 1'd1)
        }
        else{ 
            try data_in = recv ep.req {
                let key_out = call expand_key(data_in) >>
                send ep.res(aes_key_expand_out_pack::{key = key_out; error = 1'd0}) >>
                match (call should_update_rcon(data_in.ctrl.key_len, data_in.round)) {
                    1'b1 => {call set_rcon(data_in.ctrl, 1'd0)},
                    _ => cycle 1
                }
            }
            else{
                cycle 1
            }
        }
    }
}
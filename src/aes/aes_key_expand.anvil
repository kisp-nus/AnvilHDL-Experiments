import "aes_pkg.anvilh"

func aes_sub_word(data_in : logic[32]) {
    let b0 = sbox_in::{data=data_in[0+:8]; op = ciph_op_e::CIPH_FWD};
    let b1 = sbox_in::{data=data_in[8+:8]; op = ciph_op_e::CIPH_FWD};
    let b2 = sbox_in::{data=data_in[16+:8]; op = ciph_op_e::CIPH_FWD};
    let b3 = sbox_in::{data=data_in[24+:8]; op = ciph_op_e::CIPH_FWD};

    send sch0_ri.req(b0) >>
    let b0_o = recv sch0_ri.res >>
    send sch1_ri.req(b1) >>
    let b1_o = recv sch1_ri.res >>
    send sch2_ri.req(b2) >>
    let b2_o = recv sch2_ri.res >>
    send sch3_ri.req(b3) >>
    let b3_o = recv sch3_ri.res >>
    #{b3_o, b2_o, b1_o, b0_o}
}

func expand_key(data_in : aes_key_expand_in_pack) {
    let key = data_in.key;
    let key_len = data_in.ctrl.key_len;
    // let clear_i = data_in.clear;
    let op = data_in.ctrl.op;
    let rnd = data_in.round;
    let rot_word_out = match key_len {
        key_len_e::KEY_LEN_128 => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    call circ_byte_shift(key[3], 2'h1)
                },
                _ => {
                    call circ_byte_shift(key[3]^key[2], 2'h3)
                }
            }
            
        },
        key_len_e::KEY_LEN_256 => {
            match rnd[0] {
                1'b0 => {
                    match op {
                        ciph_op_e::CIPH_FWD => {
                            key[7]
                        },
                        _ => {
                            key[3]
                        }
                    }
                },
                _ =>{
                    match op {
                        ciph_op_e::CIPH_FWD => {
                            call circ_byte_shift(key[7], 2'h3)
                        },
                        _ => {
                            call circ_byte_shift(key[3], 2'h3)
                        }
                    }
                }
            }
        },
        _ => {
            //ignoring 192 bit key length for now
            key[3]
        }
    };
    let sub_word_out = call aes_sub_word(rot_word_out);
    let rcon_add_out = sub_word_out[0+:8] ^ *rcon>>
    let out = match key_len {
        key_len_e::KEY_LEN_128 => {
            let rcon_added =  #{sub_word_out[8+:24], rcon_add_out};
            #{key[3], key[2], key[1], key[0], key[2]^key[3], key[1]^key[2], key[0]^key[1], key[0]^rcon_added}
            
        },
        key_len_e::KEY_LEN_256 => {
           let rcon_added = match rnd[0]{
            1'b1 => #{sub_word_out[8+:24], rcon_add_out},
            _ => sub_word_out
            }>>
            match op {
                ciph_op_e::CIPH_FWD => {
                    match rnd{
                        3'd0 => {
                            key
                        },
                        _ => {
                            #{key[6]^key[7], key[5]^key[6], key[4]^key[5], key[4]^rcon_added, key[7],key[6], key[5], key[4]}
                        }
                    }
                },
                ciph_op_e::CIPH_INV => {
                    match rnd{
                        3'd0 => {
                            #{key[3], key[2], key[1], key[0], key[7], key[6], key[5], key[4]}
                        },
                        _ => {
                            #{key[3], key[2], key[1],key[0],key[7]^key[6],key[6]^key[5], key[5]^key[4], key[4]^rcon_added}
                        }
                    }
                },
                _ => key
            }
        },
        _ => {
            //ignoring 192 bit key length for now
            key
        }
    };
    out

}

func set_rcon(data_in, clear_i : logic[1]) {
    let op = data_in.op;
    let key_len = data_in.key_len;
    match clear_i {
        1'd1 => {
            match op{
                ciph_op_e::CIPH_FWD => {
                set rcon := 8'h01
                },
                _ => {
                    match key_len {
                        key_len_e::KEY_LEN_128 => {
                            set rcon := 8'h36
                        },
                        key_len_e::KEY_LEN_256 => {
                            set rcon := 8'h40
                        },
                        _ => {
                            set rcon := 8'h80
                        }
                    }
                }
            }
        },
        _ => {
            match op {
                ciph_op_e::CIPH_FWD => {
                    set rcon := call mul2(*rcon)

                },
                ciph_op_e::CIPH_INV => {
                    set rcon := call div2(*rcon)
                },
                _ => {
                    set rcon := 8'h01
                }
            }
        }
                
    }
}

 
proc aes_key_expand(ep : left aes_key_expand_ch) {
    chan sch0_le -- sch0_ri : sbox_ch;
    chan sch1_le -- sch1_ri : sbox_ch;
    chan sch2_le -- sch2_ri : sbox_ch;
    chan sch3_le -- sch3_ri : sbox_ch;
    spawn sbox(sch0_le);
    spawn sbox(sch1_le);
    spawn sbox(sch2_le);
    spawn sbox(sch3_le);
    reg rcon : logic[8];

    loop {
        try init = recv ep.init{
            call set_rcon(init, 1'd1)
        }
        else{ 
            let data_in = recv ep.req >>
            let key_out = call expand_key(data_in) >>
            call set_rcon(data_in.ctrl,1'd0);
            send ep.res(key_out)
        } >>

        cycle 1
    }
}
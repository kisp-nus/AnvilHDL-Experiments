
import "common_cells.anvilh"
// extern import "fifo_wrapper.sv"
import "fifo.anvil"

// proc fifo_extern (ep : left fifo_ch<logic[32]>) extern("fifo_wrapper") {
//     clk_i  ("clk_i");
//     rst_ni ("rst_ni");
//     ep.push("data_i":"push_i":);
//     ep.pop(:"pop_i":);
//     ep.data_o("data_o": :);
//     ep.full(:"full_o":);
//     ep.empty(:"empty_o":);
// }



proc fifo_top(){
    chan ep_le -- ep_ri : fifo_ch<logic[32]>;
    spawn fifo<logic[32], 8, 3>(ep_le);
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }
    loop{
        send ep_ri.push(32'd51) >>
        cycle 1 >>
        send ep_ri.push(32'd52) >>
        cycle 1 >>
        send ep_ri.push(32'd53) >>
        cycle 1 >>
        send ep_ri.push(32'd54) >>
        cycle 1 >>
        send ep_ri.push(32'd55) >>
        cycle 1 >>
        send ep_ri.push(32'd56) >>
        cycle 1 >>
        send ep_ri.push(32'd57) >>
        cycle 1 >>

        send ep_ri.push(32'd58) >>
        cycle 1 >>
        send ep_ri.push(32'd59) >>
        
        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>

        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc, data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc,data) >>


        cycle 1 >>
        send ep_ri.pop(1'b1) >>
        let data = recv ep_ri.data_o >>
        dprint "[Cycle %d] Data recieved %d" (*cyc,data) >>
        
        cycle 1 >>
        dfinish
    }

    loop{
        let empty = recv ep_ri.empty >>
        dprint "[Cycle %d] FIFO empty: %d" (*cyc, empty) >>
        cycle 1
    }

    loop{
        let full = recv ep_ri.full >>
        dprint "[Cycle %d] FIFO full: %d" (*cyc, full) >>
        cycle 1
    }
}


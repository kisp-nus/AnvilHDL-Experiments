import "../common_cells/fifo.anvil"

type prot_t = logic[3];
type resp_t = logic[2];
type strb_t = logic[4];

type select_t = logic;
type A = logic[32];
type T = logic[32];


struct aw_pack_t {
    addr : A,
    prot : prot_t
}

struct w_pack_t {
    data : T,
    strb : strb_t
}

struct b_pack_t {
    resp : resp_t
}

struct ar_pack_t {
    addr : A,
    prot : prot_t
}

struct r_pack_t {
    data : T,
    resp : resp_t
}

chan slave_ch{
    left aw_req : (aw_pack_t@#1),
    left aw_sel : (select_t@#1) @#aw_req - @#aw_req,
    
    left w_req : (w_pack_t@#1),
    

    right b_resp : (b_pack_t@#1),

    left ar_req : (ar_pack_t@#1),
    left ar_sel : (select_t@#1) @#ar_req - @#ar_req,

    right r_resp : (r_pack_t@#1),

    left sel : (select_t@#1)

}

chan master_ch {
    right mst_aw_req : (aw_pack_t@#1),
    right mst_w_req  : (w_pack_t@#1),
    left mst_b_resp  : (b_pack_t@#1),
    right mst_ar_req : (ar_pack_t@#1),
    left mst_r_resp : (r_pack_t@#1)
}

struct aw_sel_pack_t {
    aw_pack : aw_pack_t,
    select : select_t
}
struct ar_sel_pack_t {
    ar_pack : ar_pack_t,
    select : select_t
}

chan spill_ch<Tp : type> {
    right req : (Tp@#1) @dyn - @#1,
    left res : (Tp@#1) @#1 - @dyn,
    left rdy : (logic@#1) @#1 - @dyn,
    right spill : (logic@#1) @dyn - @#1
}

proc spill_reg<id: int, Tp : type, BYPASS : int> (ep : right spill_ch<Tp>) {
    reg full : logic[2];
    reg spreg : Tp[2];
    // reg cyc : logic[32];
    // loop{
    //     set cyc := *cyc + 32'd1
    // }
    
    loop {
    
        let a_full = *full[0];
        let b_full = *full[1];
        let a_q = *spreg[0];
        let b_q = *spreg[1];
        let ready_o = (*full != 2'b11);
        let a_drain = (a_full & (~ b_full));
        let valid_o = (a_full | b_full) >>
       if(ready_o){
            send ep.rdy(ready_o)
       }
       else{
        ()
       } >>
       if(valid_o == 1'b1) {
            // dprint "[Cycle %d] Spill Register %d: Valid Output %b, A Full %b, B Full %b" (*cyc, id, valid_o, a_full, b_full) >>
            if (b_full) {
                send ep.res(b_q)
            }
            else{
                send ep.res(a_q)
            }
        } 
        else{
            ()
        }>>
        
        if ((ready_o) == 1'd1) {
            try a = recv ep.req {
                
                // a_fill - 1'b1
                set spreg[0] := a;
                set full[0] := 1'b1;

                    try _ = recv ep.spill {
                        //ready_i = 1
                        // b_fill = 0
                        // b_drain  = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        //ready_i = 0
                        //b_fill = a_drain
                        //b_drain =0
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
            
            } else {
                //a_fill =0 
                if (a_drain) {
                    set full[0] := 1'b0
                }
                else{
                    cycle 1
                };
                // if (valid_o) {
                //     let resp = if (b_full) {
                //         b_q
                //     } else {
                //         a_q
                //     };
                try _ = recv ep.spill {
                        //ready_i = 1
                        //b_fill = 0
                        //b_drain = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
                // }
            }
        } else {
            // if (valid_o) {
            //     let resp = if (b_full) {
            //         b_q
            //     } else {
            //         a_q
            //     };
                try _ = recv ep.spill {
                    //ready_i = 1
                    //b_fill = 0
                    //b_drain = b_full
                    if (b_full) {
                        set full[1] := 1'b0
                    }
                    else{
                        cycle 1
                    }
                }

                else{
                    if (a_drain) {
                        set spreg[1] := a_q;
                        set full[1] := 1'd1
                    }
                    else{
                        cycle 1
                    }
                    
                }
            // }
            // else{
            //     cycle 1
            // }
        }
        
    }
}

chan fifo_ch<Tp : type> {
    left push : (Tp@#1) @#1 - @dyn,
    left pop : (logic@#1) @#1 - @dyn,
    right data_o : (Tp@#1) @#pop - @#pop,
    right full : (logic@#1) @#1 - @#1,
    right empty : (logic@#1) @#1 - @#1
}

// proc fifo_extern (ep : left fifo_ch<select_t>) extern("fifo_wrapper") {
//     clk_i  ("clk_i");
//     rst_ni ("rst_ni");
//     ep.push("data_i":"push_i":);
//     ep.pop(:"pop_i":);
//     ep.data_o("data_o": :);
//     ep.full(:"full_o":);
//     ep.empty(:"empty_o":);
// }
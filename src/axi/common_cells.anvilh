
// extern import "spill_register.sv"

// extern-proc-def ::= proc $identifier [$params] (($identifier : (left | right) $identifier [$param-vals]) | ())
//  extern($string-literal) 
//  { { (clk_i($string-literal) | rst_ni($string-literal) | $identifier.$identifier($string-literal : $string-literal : $string-literal) ) ; } }

// proc spill_reg <T : type, BYPASS : int> (right ep : spill_ch<T>)
// {
//     extern("spill_register") {
//         (clk_i("clk_i") | rst_ni("rst_ni") | ep.req("valid_i" : "data_i") | ep.res("valid_o" : "ready_i" : "data_o"));
//     }
// }
struct w_pack<T : type, S : int> {
    data : T,
    select : logic[S]
}
struct aw_pack<A : type, S : int> {
    data : A,
    select : logic[S]
}
type b_pack = logic[1];
// Read Data Structs
struct ar_pack<A : type, S : int> {
    data : A,
    select : logic[S]
}
struct r_pack<T : type> {    
    data : T
}
chan spill_ch<T : type> {
    left req : (T@#1),
    right res : (T@#1)
}
chan slave_ch<T :type , A : type , select_t:int> {
    left slv_req_aw : (aw_pack<A, select_t>@#1),
    left slv_req_w  : (w_pack<T, select_t>@#1),
    right slv_res_b : (b_pack@#1),
    left slv_req_ar : (ar_pack<A, select_t>@#1),
    right slv_res_r : (r_pack<T>@#1)
}
chan master_ch<T : type , A : type> {
    right mst_aw_req : (T@#1),
    right mst_w_req  : (A@#1),
    left mst_b_resp  : (b_pack@#1),
    right mst_ar_req : (A@#1),
    left mst_r_resp : (r_pack<T>@#1)
}

proc spill_reg<T : type, BYPASS : int> (ep : left spill_ch<T>) {
    reg full : logic[2];
    reg spreg : T[2];
    loop {
    
        let a_full = *full[0];
        let b_full = *full[1];
        let a_q = *spreg[0];
        let b_q = *spreg[1];
        let ready_o = (*full != 2'b11);
        let a_drain = (a_full & (~ b_full));
        let valid_o = (a_full | b_full) >>
        
        if ((ready_o) == 1'd1) {
            try a = recv ep.req {
                
                // a_fill - 1'b1
                set spreg[0] := a;
                set full[0] := 1'b1;
                
                if (valid_o) {
                    let resp = if (b_full) {
                        b_q
                    } else {
                        a_q
                    };
                    
                    try send ep.res(resp) {
                        //ready_i = 1
                        // b_fill = 0
                        // b_drain  = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        //ready_i = 0
                        //b_fill = a_drain
                        //b_drain =0
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
                }
                else{
                    cycle 1
                }
            } else {
                //a_fill =0 
                if (a_drain) {
                    set full[0] := 1'b0
                }
                else{
                    cycle 1
                };
                if (valid_o) {
                    let resp = if (b_full) {
                        b_q
                    } else {
                        a_q
                    };
                    try send ep.res(resp) {
                        //ready_i = 1
                        //b_fill = 0
                        //b_drain = b_full
                        if (b_full) {
                            set full[1] := 1'b0
                        }
                        else{
                            cycle 1
                        }
                    } else {
                        if (a_drain) {
                            set spreg[1] := a_q;
                            set full[1] := 1'd1
                        }
                        else{
                            cycle 1
                        }
                    }
                }
                else{
                    cycle 1
                }
            }
        } else {
            if (valid_o) {
                let resp = if (b_full) {
                    b_q
                } else {
                    a_q
                };
                try send ep.res(resp) {
                    //ready_i = 1
                    //b_fill = 0
                    //b_drain = b_full
                    if (b_full) {
                        set full[1] := 1'b0
                    }
                    else{
                        cycle 1
                    }
                }

                else{
                    if (a_drain) {
                        set spreg[1] := a_q;
                        set full[1] := 1'd1
                    }
                    else{
                        cycle 1
                    }
                    
                }
            }
            else{
                cycle 1
            }
        }
     
        
    }
}

chan fifo_ch<T : type> {
    left push : (logic[1]@#1),
    right pop : (T@#1),
    right full : (logic[1]@#1),
    right empty : (logic[1]@#1)
}

proc fifo<D: type, S: type>(ep : left fifo_ch<S>) {

    loop{
        cycle 1
    }
}

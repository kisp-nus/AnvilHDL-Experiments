
import "common_cells.anvilh"

proc axi_demux<
                T : type,
                A : type,
              aw_pack_t : type,
              w_pack_t : type,
              b_pack_t : type,
              ar_pack_t : type,
              r_pack_t : type,
              AW_BYPASS : int,
              W_BYPASS : int,
              B_BYPASS : int,
              AR_BYPASS : int,
              R_BYPASS : int,
              NoMstPorts : int
            >
(
    slv_ep: left slave_ch,
    mst_ep_0: left master_ch,
    mst_ep_1: left master_ch
)
// Write Translaction and read trannsaction to be implemented seperately (in different loops for now)
{
    chan aw_sr_le -- aw_sr_ri : spill_ch< aw_sel_pack_t >;
    chan w_sr_le -- w_sr_ri : spill_ch< w_pack_t >;
    chan b_sr_le -- b_sr_ri : spill_ch< b_pack_t >;
    chan ar_sr_le -- ar_sr_ri : spill_ch< ar_sel_pack_t >;
    chan r_sr_le -- r_sr_ri : spill_ch< r_pack_t >;
    chan w_fifo_le -- w_fifo_ep : fifo_ch<select_t>;
    chan b_fifo_le -- b_fifo_ep : fifo_ch<select_t>;
    chan r_fifo_le -- r_fifo_ep : fifo_ch<select_t>;
    spawn fifo<select_t,8,3>(w_fifo_le);
    spawn fifo<select_t,8,3>(b_fifo_le);
    spawn fifo<select_t,8,3>(r_fifo_le);
    spawn spill_reg< 1,aw_sel_pack_t , AW_BYPASS >(aw_sr_ri);
    spawn spill_reg< 2, w_pack_t , W_BYPASS >(w_sr_ri);
    spawn spill_reg< 3, b_pack_t , B_BYPASS >(b_sr_ri);
    spawn spill_reg< 4, ar_sel_pack_t , AR_BYPASS >(ar_sr_ri);
    spawn spill_reg< 5, r_pack_t , R_BYPASS >(r_sr_ri);
    // reg cyc : logic[32];
    // loop{
    //     set cyc := *cyc + 32'd1
    // }

//---------------------------------------------Write Transaction------------------------------------------------------------
    loop{//AW slv req bypass
        try _ = recv aw_sr_le.rdy{
            let aw_req = recv slv_ep.aw_req  >>
            let sel = recv slv_ep.aw_sel >>
            let aw_sel_pack = aw_sel_pack_t::{
                aw_pack = aw_req;
                select = sel
            };
            
            send aw_sr_le.req(aw_sel_pack)//To Do: add syncpattern as anytime immmediately after a message
        } >>
        cycle 1
    }


    loop{ //AW Channel Transaction To Do: add parametrized register by passing
    /*1.*/  let f = recv w_fifo_ep.full >>
            if (f == 1'b1){
                cycle 1
            }
            else{
                  let aw_req = recv aw_sr_le.res >> //sync pattern to say ready to recieve immediately
                //   dprint "[Cycle %d] Recieved AW Request" (*cyc) >>
                  send w_fifo_ep.push(aw_req.select) >>
                  match aw_req.select{
                    0 => {
                            send mst_ep_0.mst_aw_req(aw_req.aw_pack) >>
                            send aw_sr_le.spill(1'd1) //
                    },
                    1 => {
                            send mst_ep_1.mst_aw_req(aw_req.aw_pack) >>
                            send aw_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                    },
                    _ => {
                            // can keep doing the match
                            ()
                        }
                  }>> cycle 1
            }
        }

        // W Channel Transaction

        loop{//W slv req bypass
            try _ = recv w_sr_le.rdy{
                let w_req = recv slv_ep.w_req >>
                send w_sr_le.req(w_req)//To Do: add syncpattern as anytime immmediately after a message
            } >>
            cycle 1
        }
        
        loop{ // The FSM that controls the w channel transaction
            let e = recv w_fifo_ep.empty  >>
            if (e == 1'b1){
                cycle 1
            }
            else {
                let f = recv b_fifo_ep.full >>
                if (f == 1'b1){
                    cycle 1
                }
                else {
                    send w_fifo_ep.pop(1'd1) >>
                    let w_mst = recv w_fifo_ep.data_o >>
                    send b_fifo_ep.push(w_mst) >>
                    match w_mst{
                        0 =>{
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_0.mst_w_req(w_req) >>
                            send w_sr_le.spill(1'd1)
                        },
                        1 => {
                            let w_req = recv w_sr_le.res >>
                            send mst_ep_1.mst_w_req(w_req) >>
                            send w_sr_le.spill(1'd1)
                        },
                        _ => {
                            // can keep doing the match
                            ()
                        }
                    } >>
                    cycle 1
                }
            }
        }
// B channel Transaction
    
    loop{// Master to bypass the value to spill register
        let e = recv b_fifo_ep.empty >>
        if (e == 1'b1){
            cycle 1
        }
        else {
            try _ = recv b_sr_le.rdy {
                send b_fifo_ep.pop(1'd1) >>
                let b_mst = recv b_fifo_ep.data_o >>
                match b_mst {
                    0 => {
                        let b = recv mst_ep_0.mst_b_resp >>
                        send b_sr_le.req(b)
                    },
                    1 => {
                        let b = recv mst_ep_1.mst_b_resp >>
                        send b_sr_le.req(b)
                    },
                    _ => {
                        // can keep doing the match
                        ()
                    }
                }
            } >>
            cycle 1
        }
    }

    loop {
        // slave gets the b response (spill register bypass)
        let b_resp = recv b_sr_le.res >>
        send slv_ep.b_resp(b_resp) >>
        send b_sr_le.spill(1'd1) >> //sync pattern to say ready to spill the value
        cycle 1
    }
// ----------------------------------------------Read Transaction------------------------------------------------------------

    loop{//AR slv req bypass
        try _ = recv ar_sr_le.rdy{
            let ar_req = recv slv_ep.ar_req >>
            let sel = recv slv_ep.ar_sel >>
            let rdy = ready slv_ep.ar_req >>
            // dprint "[Cycle %d] %d AR Request: %h | %h" (*cyc, rdy,ar_req.addr, sel) >>
            let ar_sel_pack = ar_sel_pack_t::{
                ar_pack = ar_req;
                select = sel
            };
            send ar_sr_le.req(ar_sel_pack)//To Do: add syncpattern as anytime immmediately after a message
        } >>
        cycle 1
    }

    loop{ //AR Channel Transaction To Do: add parametrized register by passing
    /*1.*/  let f = recv r_fifo_ep.full >>
            if (f == 1'b1){
                cycle 1
            }
            else{
                  let ar_req = recv ar_sr_le.res >> //sync pattern to say ready to recieve immediately
                  send r_fifo_ep.push(ar_req.select) >>
                  match ar_req.select{
                    0 => {
                            send mst_ep_0.mst_ar_req(ar_req.ar_pack) >>
                            send ar_sr_le.spill(1'd1) //
                    },
                    1 => {
                            send mst_ep_1.mst_ar_req(ar_req.ar_pack) >>
                            send ar_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                    },
                    _ => {
                            // can keep doing the match
                            ()
                        }
                  }>> cycle 1
            }
     }

    // R Data Transaction
    loop{    
        let e = recv r_fifo_ep.empty >>
        if (e == 1'b1){
            cycle 1
        }
        else {
            send r_fifo_ep.pop(1'd1) >>
            let r_mst = recv r_fifo_ep.data_o >>
            match r_mst {
                0 => {
                        let _ = recv r_sr_le.rdy >>
                        let r_res = recv mst_ep_0.mst_r_resp >>
                        send r_sr_le.req(r_res)
                },
                1 => {
                        let _ = recv r_sr_le.rdy >>
                        let r_res = recv mst_ep_1.mst_r_resp >>
                        send r_sr_le.req(r_res)
                },
                _ => {
                        // can keep doing the match
                        ()
                }
            } >>
            cycle 1
        }
    }

    loop {
        let resp = recv r_sr_le.res >>
        send slv_ep.r_resp(resp) >>
        send r_sr_le.spill(1'd1) >>
        cycle 1
    }

// ------------------------------------End of the axi demux------------------------------------------------
}



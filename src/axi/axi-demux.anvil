
import "common_cells.anvilh"

proc axi_demux<
                T : type,
                A : type,
              aw_pack_t : type,
              w_pack_t : type,
              b_pack_t : type,
              ar_pack_t : type,
              r_pack_t : type,
              AW_BYPASS : int,
              W_BYPASS : int,
              B_BYPASS : int,
              AR_BYPASS : int,
              R_BYPASS : int,
              NoMstPorts : int
            >
(
    slv_ep: left slave_demux_ch,
    mst_ep_0: left master_ch,
    mst_ep_1: left master_ch,
    mst_ep_2 : left master_ch,
    mst_ep_3 : left master_ch,
    mst_ep_4 : left master_ch,
    mst_ep_5 : left master_ch,
    mst_ep_6 : left master_ch,
    mst_ep_7 : left master_ch
)
// Write Translaction and read trannsaction to be implemented seperately (in different loops for now)
{
    chan aw_sr_le -- aw_sr_ri : spill_ch< aw_sel_pack_t >;
    chan w_sr_le -- w_sr_ri : spill_ch< w_pack_t >;
    chan b_sr_le -- b_sr_ri : spill_ch< b_pack_t >;
    chan ar_sr_le -- ar_sr_ri : spill_ch< ar_sel_pack_t >;
    chan r_sr_le -- r_sr_ri : spill_ch< r_pack_t >;
    chan w_fifo_le -- w_fifo_ep : fifo_ch<select_t>;
    chan b_fifo_le -- b_fifo_ep : fifo_ch<select_t>;
    chan r_fifo_le -- r_fifo_ep : fifo_ch<select_t>;
    spawn fifo<select_t,8,3>(w_fifo_le);
    spawn fifo<select_t,8,3>(b_fifo_le);
    spawn fifo<select_t,8,3>(r_fifo_le);
    spawn spill_reg< 1,aw_sel_pack_t , AW_BYPASS >(aw_sr_ri);
    spawn spill_reg< 2, w_pack_t , W_BYPASS >(w_sr_ri);
    spawn spill_reg< 3, b_pack_t , B_BYPASS >(b_sr_ri);
    spawn spill_reg< 4, ar_sel_pack_t , AR_BYPASS >(ar_sr_ri);
    spawn spill_reg< 5, r_pack_t , R_BYPASS >(r_sr_ri);
    // reg cyc : logic[32];
    // loop{
    //     set cyc := *cyc + 32'd1
    // }

//---------------------------------------------Write Transaction------------------------------------------------------------
    loop{//AW slv req bypass
        let rdy = recv aw_sr_le.rdy >>
        if (rdy == 1'd1){
            try aw_req = recv slv_ep.aw_req {
                let sel = recv slv_ep.aw_sel >>
                let aw_sel_pack = aw_sel_pack_t::{
                    aw_pack = aw_req;
                    select = sel
                } >>
            
                send aw_sr_le.req(aw_sel_pack)//To Do: add syncpattern as anytime immmediately after a message
            }
        } >>
        cycle 1
    }


    loop{ //AW Channel Transaction To Do: add parametrized register by passing
    /*1.*/  let f = recv w_fifo_ep.full >>
            if(f == 1'b0){
                  try aw_req = recv aw_sr_le.res{
                  let tc = match aw_req.select{
                    3'd0 => {
                            try send mst_ep_0.mst_aw_req(aw_req.aw_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd1 => {
                            try send mst_ep_1.mst_aw_req(aw_req.aw_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd2 => {
                            try send mst_ep_2.mst_aw_req(aw_req.aw_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd3 => {
                            try send mst_ep_3.mst_aw_req(aw_req.aw_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd4 => {
                            try send mst_ep_4.mst_aw_req(aw_req.aw_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd5 => {
                            try send mst_ep_5.mst_aw_req(aw_req.aw_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd6 => {
                            try send mst_ep_6.mst_aw_req(aw_req.aw_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    _ => {
                            try send mst_ep_7.mst_aw_req(aw_req.aw_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    }
                  } >>
                  if(tc){
                    send w_fifo_ep.push(aw_req.select) >>
                    send aw_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                  }
                }
            } >>
            cycle 1
                
    }

        // W Channel Transaction

        loop{//W slv req bypass
            let rdy = recv w_sr_le.rdy >>
            if (rdy == 1'd1){
                try w_req = recv slv_ep.w_req{
                    send w_sr_le.req(w_req)//To Do: add syncpattern as anytime immmediately after a message
                }
            } >>
            cycle 1
        }
        
        loop{ // The FSM that controls the w channel transaction
            let e = recv w_fifo_ep.empty  >>
            let f = recv b_fifo_ep.full >>
            if ((e == 1'b0) && (f == 1'b0)){
                    let w_mst = recv w_fifo_ep.data_o >>
                    // let rd1 = (probe mst_ep_0.mst_w_req) >>
                    // let rd2 = (probe mst_ep_1.mst_w_req) >>
                    // let rd3 = (probe mst_ep_2.mst_w_req)  >>
                    // let rd4 = (probe mst_ep_3.mst_w_req)  >>
                    // let rd5 = (probe mst_ep_4.mst_w_req)  >>
                    // let rd6 = (probe mst_ep_5.mst_w_req)  >>
                    // let rd7 = (probe mst_ep_6.mst_w_req)  >>
                    // let rd8 = (probe mst_ep_7.mst_w_req)  >>
                    // let rd_mask = #{rd8,rd7,rd6,rd5,rd4,rd3,rd2,rd1} >>
                    
                    // if (rd_mask[w_mst]){
                    //     send b_fifo_ep.push(w_mst) 
                    // } >>
                    
                try w_req = recv w_sr_le.res{
                   let tc = match w_mst{
                        3'd0 =>{
                            
                            try send mst_ep_0.mst_w_req(w_req){
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        3'd1 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_1.mst_w_req(w_req){
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        3'd2 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_2.mst_w_req(w_req){
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        3'd3 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_3.mst_w_req(w_req){
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        3'd4 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_4.mst_w_req(w_req) {
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else {
                                1'd0
                            }
                        },
                        3'd5 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_5.mst_w_req(w_req) {
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        3'd6 => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_6.mst_w_req(w_req) {
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                        },
                        _ => {
                            // let w_req = recv w_sr_le.res >>
                            try send mst_ep_7.mst_w_req(w_req) {
                                
                    //            send w_sr_le.spill(1'd1) >>
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                        }
                        
                    } >>
                    if(tc){
                        send w_fifo_ep.pop(1'd1) >>
                        send b_fifo_ep.push(w_mst) >>
                        send w_sr_le.spill(1'd1) 
                    }
                }
                
            } >>
            cycle 1
        }
// B channel Transaction
    
    loop{// Master to bypass the value to spill register
        let e = recv b_fifo_ep.empty >>
        let rdy = recv b_sr_le.rdy >>
        if (e == 1'b0 && rdy == 1'd1){
                // send b_fifo_ep.pop(1'd1) >>
                let b_mst = recv b_fifo_ep.data_o >>
                let b_null = <(2'd0)::b_pack_t> >>
                let tc = match b_mst {
                    3'd0 => {
                        try b = recv mst_ep_0.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                    },
                    3'd1 => {
                        try b = recv mst_ep_1.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                    },
                    3'd2 => {
                        try b = recv mst_ep_2.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                    },
                    3'd3 => {
                        try b = recv mst_ep_3.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                    },
                    3'd4 => {
                        try b = recv mst_ep_4.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                            
                    },
                    3'd5 => {
                        try b = recv mst_ep_5.mst_b_resp {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                        
                    },
                    3'd6 => {
                        try b = recv mst_ep_6.mst_b_resp  {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                        
                    },
                    _ => {
                        try b = recv mst_ep_7.mst_b_resp  {
                            // send b_fifo_ep.pop(1'd1) >>
                            // send b_sr_le.req(b)
                            #flat{b,1'd1}
                        }
                        else{
                            #flat{b_null,1'd0}
                        }
                    }
               
                } >>
                
                if(tc[0]){
                    send b_fifo_ep.pop(1'd1) >>
                    send b_sr_le.req(<(tc[1+:2])::b_pack_t>)
                }
            }  >>
        
        cycle 1
    }

    loop {
        // slave gets the b response (spill register bypass)
        try b_resp = recv b_sr_le.res {
            try send slv_ep.b_resp(b_resp){
                send b_sr_le.spill(1'd1)
            } 
        } >>
        cycle 1
    }
// ----------------------------------------------Read Transaction------------------------------------------------------------

    loop{//AR slv req bypass
        let rdy = recv ar_sr_le.rdy >>
        if (rdy == 1'd1) {
            try ar_req = recv slv_ep.ar_req {
                let sel = recv slv_ep.ar_sel >>
                // dprint "[Cycle %d] %d AR Request: %h | %h" (*cyc, rdy,ar_req.addr, sel) >>
                let ar_sel_pack = ar_sel_pack_t::{
                    ar_pack = ar_req;
                    select = sel
                } >>
                send ar_sr_le.req(ar_sel_pack)//To Do: add syncpattern as anytime immmediately after a message
            }
        } >>
        cycle 1
    }

    loop{ //AR Channel Transaction To Do: add parametrized register by passing
    /*1.*/  let f = recv r_fifo_ep.full >>
            if (f == 1'b0){
                try ar_req = recv ar_sr_le.res {
                  let tc = match ar_req.select{
                    3'd0 => {
                            try send mst_ep_0.mst_ar_req(ar_req.ar_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd1 => {
                            try send mst_ep_1.mst_ar_req(ar_req.ar_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd2 => {
                            try send mst_ep_2.mst_ar_req(ar_req.ar_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    },
                    3'd3 => {
                            try send mst_ep_3.mst_ar_req(ar_req.ar_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd4 => {
                            try send mst_ep_4.mst_ar_req(ar_req.ar_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd5 => {
                            try send mst_ep_5.mst_ar_req(ar_req.ar_pack){
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    3'd6 => {
                            try send mst_ep_6.mst_ar_req(ar_req.ar_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                            
                    },
                    _ => {
                            try send mst_ep_7.mst_ar_req(ar_req.ar_pack) {
                                1'd1
                            }
                            else{
                                1'd0
                            }
                    }
                  } >>
                  if(tc){
                    send r_fifo_ep.push(ar_req.select) >>
                    send ar_sr_le.spill(1'd1) //sync pattern to say ready to accept after previous spill
                  }
                }
            } >>
            cycle 1
                
    }

    // R Data Transaction
    loop{    
        let e = recv r_fifo_ep.empty >>
        let rdy =  recv r_sr_le.rdy >>
        if ((e == 1'b0)&& (rdy == 1'b1)){
            let r_mst = recv r_fifo_ep.data_o >>
            let r_null = (<(34'd0)::r_pack_t>) >>
            let tc = match r_mst {
                3'd0 => {
                    try r_res = recv mst_ep_0.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd1 => {
                    try r_res = recv mst_ep_1.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd2 => {
                    try r_res = recv mst_ep_2.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd3 => {
                    try r_res = recv mst_ep_3.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd4 => {
                    try r_res = recv mst_ep_4.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd5 => {
                    try r_res = recv mst_ep_5.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                3'd6 => {
                    try r_res = recv mst_ep_6.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                },
                _ => {
                    try r_res = recv mst_ep_7.mst_r_resp {
                        #flat{r_res,1'd1}
                    }
                    else{
                        #flat{r_null,1'd0}
                    }
                }
            } >>
            
            if(tc[0]){
                send r_fifo_ep.pop(1'd1) >>
                send r_sr_le.req(<(tc[1+:34])::r_pack_t>)
            }
        } >>
        cycle 1
    }

    loop {
        try resp = recv r_sr_le.res {
            try send slv_ep.r_resp(resp) {
                send r_sr_le.spill(1'd1)
            }
        } >>
        cycle 1
    }

// ------------------------------------End of the axi demux------------------------------------------------
}



import "axi-demux.anvil"


proc axi_router_top()
{
    chan slv_ep_le -- slv_ep_ri : slave_ch;
    chan ep0_le -- ep0_ri : master_ch;
    chan ep1_le -- ep1_ri : master_ch;
    spawn master_dummy<1>(ep0_ri);
    spawn master_dummy<2>(ep1_ri);
    spawn axi_demux<
                    logic[32], logic[32],
                    aw_pack_t, w_pack_t, b_pack_t, ar_pack_t, r_pack_t,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2>
(slv_ep_le, ep0_le, ep1_le);



reg cyc : logic[32];
reg mem : logic[8][32];
loop{
    set cyc := *cyc + 32'd1
}


// Slave Endpoint
    loop {
        dprint "[Cycle %d] Sending AW Request" (*cyc) >>
        send slv_ep_ri.aw_req(aw_pack_t::{
            addr = <(32'h00000001)::A >;
            prot = <(3'b000)::prot_t >
        }) >>
        send slv_ep_ri.aw_sel(< (1'd1)::select_t >) >>
        dprint "[Cycle %d] AW Request sent" (*cyc) >>
        cycle 1 >>
        send slv_ep_ri.w_req(w_pack_t::{
            data = <(32'hdeadbeef)::T>;
            strb = <(8'hff)::strb_t>
        }) >>
        dprint "[Cycle %d] W Request sent" (*cyc) >>
        cycle 1 >>
        let b_resp = recv slv_ep_ri.b_resp >>
        dprint "[Cycle %d] Received b_resp: %b" (*cyc, b_resp.resp) >>

        send slv_ep_ri.ar_req(ar_pack_t::{
            addr = <(32'h00000001)::A >;
            prot = <(3'b000)::prot_t >
        }) >>
        send slv_ep_ri.ar_sel(< (1'd1)::select_t >) >>
        dprint "[Cycle %d] AR Request sent" (*cyc) >>
        cycle 1 >>
        let r_resp = recv slv_ep_ri.r_resp >>
        dprint "[Cycle %d] Received r_resp: %h | resp = %b" (*cyc, r_resp.data, r_resp.resp) >>
        cycle 10 >>
        dfinish >>
        cycle 1
        
    }
    
}


proc master_dummy<id : int>(ep : right master_ch)
{
    reg mem : T[8];
    reg addr : A;
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }

    loop{
        let aw_req =  recv ep.mst_aw_req >>
        dprint "[Cycle %d] Master %d AW Request: %h" (*cyc, id, aw_req.addr) >>
        set addr := aw_req.addr >>

        let w_req = recv ep.mst_w_req >>
        dprint "[Cycle %d] Master %d W Request: %h" (*cyc, id, w_req.data) >>

        set mem[*addr[0+:3]] := w_req.data >>

        let b_resp = b_pack_t::{
            resp = <(2'b11)::resp_t>
        } >>
        
        send ep.mst_b_resp(b_resp) >>
        cycle 1
    }
    loop{
        let ar_req = recv ep.mst_ar_req >>
        dprint "[Cycle %d] Master %d AR Request: %h" (*cyc, id, ar_req.addr) >>
        
        set addr := ar_req.addr >>

        let r_resp = r_pack_t::{
            data = *mem[*addr[0+:3]];
            resp = <(2'b00)::resp_t>
        } >>
        
        send ep.mst_r_resp(r_resp) >>
        dprint "[Cycle %d] Master %d R Response: %h | resp = %b" (*cyc, id, r_resp.data, r_resp.resp) >>
        cycle 1

    }
}
import "axi-demux.anvil"


proc axi_router_top()
{
    chan slv_ep_le -- slv_ep_ri : slave_demux_ch;
    chan ep0_le -- ep0_ri : master_ch;
    chan ep1_le -- ep1_ri : master_ch;
    chan ep2_le -- ep2_ri : master_ch;
    chan ep3_le -- ep3_ri : master_ch;
    chan ep4_le -- ep4_ri : master_ch;
    chan ep5_le -- ep5_ri : master_ch;
    chan ep6_le -- ep6_ri : master_ch;
    chan ep7_le -- ep7_ri : master_ch;
    
    spawn master_dummy<1>(ep0_ri);
    spawn master_dummy<2>(ep1_ri);
    spawn master_dummy<3>(ep2_ri);
    spawn master_dummy<4>(ep3_ri);
    spawn master_dummy<5>(ep4_ri);
    spawn master_dummy<6>(ep5_ri);
    spawn master_dummy<7>(ep6_ri);
    spawn master_dummy<8>(ep7_ri);

    spawn axi_demux<
                    logic[32], logic[32],
                    aw_pack_t, w_pack_t, b_pack_t, ar_pack_t, r_pack_t,
                    0,
                    0,
                    0,
                    0,
                    0,
                    8>
(slv_ep_le, ep0_le, ep1_le,ep2_le,ep3_le,ep4_le,ep5_le,ep6_le,ep7_le);


reg cyc : logic[32];
reg mem : logic[8][32];
loop{
    set cyc := *cyc + 32'd1
}


// Slave Endpoint
    loop {
        generate_seq(i : 0, 7,1){
            dprint "[Cycle %d] Sending AW Request" (*cyc) >>
            send slv_ep_ri.aw_req(aw_pack_t::{
                addr = <(32'h00000001)::A >;
                prot = <(3'b000)::prot_t >
            }) >>
            let idx = i >>
            send slv_ep_ri.aw_sel(<(idx)::select_t >) >>
            dprint "[Cycle %d] AW Request sent" (*cyc) >>
            cycle 1 >>
            send slv_ep_ri.w_req(w_pack_t::{
                data = <(32'hdeadbeef)::T>;
                strb = <(4'hf)::strb_t>
            }) >>
            dprint "[Cycle %d] W Request sent" (*cyc) >>
            cycle 1 >>
            let b_resp = recv slv_ep_ri.b_resp >>
            dprint "[Cycle %d] Received b_resp: %b" (*cyc, b_resp.resp) >>

            send slv_ep_ri.ar_req(ar_pack_t::{
                addr = <(32'h00000001)::A >;
                prot = <(3'b000)::prot_t >
            }) >>
            send slv_ep_ri.ar_sel(<(idx)::select_t >) >>
            dprint "[Cycle %d] AR Request sent" (*cyc) >>
            cycle 1 >>
            let r_resp = recv slv_ep_ri.r_resp >>
            dprint "[Cycle %d] Received r_resp: %h | resp = %b" (*cyc, r_resp.data, r_resp.resp) >>
            cycle 1
        } >>
        dfinish >>
        cycle 1
        
    }
    
}


proc master_dummy<id : int>(ep : right master_ch)
{
    reg mem : T[8];
    reg addr : A;
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }

    loop{
        let aw_req =  recv ep.mst_aw_req >>
        dprint "[Cycle %d] Master %d AW Request: %h" (*cyc, id, aw_req.addr) >>
        set addr := aw_req.addr >>

        let w_req = recv ep.mst_w_req >>
        dprint "[Cycle %d] Master %d W Request: %h" (*cyc, id, w_req.data) >>

        set mem[*addr[0+:3]] := w_req.data >>

        let b_resp = b_pack_t::{
            resp = <(2'b11)::resp_t>
        } >>
        
        send ep.mst_b_resp(b_resp) >>
        cycle 1
    }
    loop{
        let ar_req = recv ep.mst_ar_req >>
        dprint "[Cycle %d] Master %d AR Request: %h" (*cyc, id, ar_req.addr) >>
        
        set addr := ar_req.addr >>

        let r_resp = r_pack_t::{
            data = *mem[*addr[0+:3]];
            resp = <(2'b00)::resp_t>
        } >>
        
        send ep.mst_r_resp(r_resp) >>
        dprint "[Cycle %d] Master %d R Response: %h | resp = %b" (*cyc, id, r_resp.data, r_resp.resp) >>
        cycle 1

    }
}
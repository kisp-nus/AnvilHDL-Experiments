import "axi_lite_mux.anvil"


proc axi_lite_mux_top()
{
    chan slv_ep_le_0 -- slv_ep_ri_0 : slave_mux_ch;
    chan slv_ep_le_1 -- slv_ep_ri_1 : slave_mux_ch;
    chan slv_ep_le_2 -- slv_ep_ri_2 : slave_mux_ch;
    chan slv_ep_le_3 -- slv_ep_ri_3 : slave_mux_ch;
    chan slv_ep_le_4 -- slv_ep_ri_4 : slave_mux_ch;
    chan slv_ep_le_5 -- slv_ep_ri_5 : slave_mux_ch;
    chan slv_ep_le_6 -- slv_ep_ri_6 : slave_mux_ch;
    chan slv_ep_le_7 -- slv_ep_ri_7 : slave_mux_ch;

    chan ep_le -- ep_ri : master_ch;
    spawn master_node(ep_ri);
    spawn slave_node<1>(slv_ep_ri_0);
    spawn slave_node<2>(slv_ep_ri_1);
    spawn slave_node<3>(slv_ep_ri_2);
    spawn slave_node<4>(slv_ep_ri_3);
    spawn slave_node<5>(slv_ep_ri_4);
    spawn slave_node<6>(slv_ep_ri_5);
    spawn slave_node<7>(slv_ep_ri_6);
    spawn slave_node<8>(slv_ep_ri_7);

    spawn axi_lite_mux<
                    aw_pack_t, w_pack_t, b_pack_t, ar_pack_t, r_pack_t,
                    0,
                    0,
                    0,
                    0,
                    0,
                    8,
                    8>
(slv_ep_le_0, slv_ep_le_1, slv_ep_le_2, slv_ep_le_3, slv_ep_le_4, slv_ep_le_5, slv_ep_le_6, slv_ep_le_7, ep_le);


loop{
    cycle 100 >>
    dfinish >>
    cycle 1
}
    
}

proc slave_node<id : int> (slv_ep_ri : right slave_mux_ch)
{
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }
    loop {
        let addri = <(id)::A> >>
        let datab = <(id)::T> >>
        let datai = ~datab >>
        // dprint "[Cycle %d][Node %d] Sending AW Request" (*cyc,id) >>
        send slv_ep_ri.aw_req(aw_pack_t::{
            addr = addri;
            prot = <(3'b000)::prot_t >
        }) >>
        // send slv_ep_ri.aw_sel(< (1'd1)::select_t >) >>
        // dprint "[Cycle %d][Node %d] AW Request sent" (*cyc,id) >>
        cycle 1 >>
        send slv_ep_ri.w_req(w_pack_t::{
            data = addri;
            strb = <(4'hf)::strb_t>
        }) >>
        // dprint "[Cycle %d][Node %d] W Request sent" (*cyc,id) >>
        cycle 1 >>
        let b_resp = recv slv_ep_ri.b_resp >>
        // dprint "[Cycle %d][Node %d] Received b_resp: %b" (*cyc,id, b_resp.resp) >>

        send slv_ep_ri.ar_req(ar_pack_t::{
            addr = addri;
            prot = <(3'b000)::prot_t >
        }) >>
        // send slv_ep_ri.ar_sel(< (1'd1)::select_t >) >>
        // dprint "[Cycle %d][Node %d] AR Request sent" (*cyc,id) >>
        cycle 1 >>
        let r_resp = recv slv_ep_ri.r_resp >>
        // dprint "[Cycle %d][Node %d] Received r_resp: %h | resp = %b" (*cyc,id, r_resp.data, r_resp.resp) >>
        cycle 1
    }
}

proc master_node(ep : right master_ch)
{
    reg mem : T[8];
    reg addr : A;
    reg cyc : logic[32];
    loop{
        set cyc := *cyc + 32'd1
    }

    loop{
        let aw_req =  recv ep.mst_aw_req >>
        dprint "[Cycle %d] Master AW Request: %h" (*cyc, aw_req.addr) >>
        set addr := aw_req.addr >>

        let w_req = recv ep.mst_w_req >>
        // dprint "[Cycle %d] Master W Request: %h" (*cyc, w_req.data) >>

        set mem[*addr[0+:3]] := w_req.data >>

        let b_resp = b_pack_t::{
            resp = <(2'b11)::resp_t>
        } >>
        
        send ep.mst_b_resp(b_resp) >>
        cycle 1
    }
    loop{
        let ar_req = recv ep.mst_ar_req >>
        // dprint "[Cycle %d] Master AR Request: %h" (*cyc, ar_req.addr) >>

        set addr := ar_req.addr >>

        let r_resp = r_pack_t::{
            data = *mem[*addr[0+:3]];
            resp = <(2'b00)::resp_t>
        } >>
        
        send ep.mst_r_resp(r_resp) >>
        // /dprint "[Cycle %d] Master R Response: %h | resp = %b" (*cyc, r_resp.data, r_resp.resp) >>
        cycle 1

    }
}
import "common_cells.anvilh"

proc axi_lite_mux<
                aw_pack_t : type,
                w_pack_t : type,
                b_pack_t : type,
                ar_pack_t : type,
                r_pack_t : type,
                AW_BYPASS : int,
                W_BYPASS : int,
                B_BYPASS : int,
                AR_BYPASS : int,
                R_BYPASS : int,
                NoSlvPorts : int,
                MaxTrans : int
            >
(
    // Multiple slave ports (input from masters)
    slv_ep_0 : left slave_mux_ch,
    slv_ep_1 : left slave_mux_ch,
    slv_ep_2 : left slave_mux_ch,
    slv_ep_3 : left slave_mux_ch,
    slv_ep_4 : left slave_mux_ch,
    slv_ep_5 : left slave_mux_ch,
    slv_ep_6 : left slave_mux_ch,
    slv_ep_7 : left slave_mux_ch,
    // Single master port (output to slave)
    mst_ep : left master_ch
)
// AXI Lite Multiplexer: Multiple slave ports -> One master port
{
    // Create default values for data types
    
    
    chan aw_sr_le -- aw_sr_ri : spill_ch< aw_sel_pack_t >;
    chan w_sr_le -- w_sr_ri : spill_ch< w_pack_t >;
    chan b_sr_le -- b_sr_ri : spill_ch< b_pack_t >;
    chan ar_sr_le -- ar_sr_ri : spill_ch< ar_sel_pack_t >;
    chan r_sr_le -- r_sr_ri : spill_ch< r_pack_t >;
    
    
    chan w_fifo_le -- w_fifo_ep : fifo_ch<select_t>;
    chan b_fifo_le -- b_fifo_ep : fifo_ch<select_t>;
    chan r_fifo_le -- r_fifo_ep : fifo_ch<select_t>;
    
    // Round-robin arbiter channels for AW and AR
    chan aw_arb_slv_ep_0_le -- aw_arb_slv_ep_0_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_1_le -- aw_arb_slv_ep_1_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_2_le -- aw_arb_slv_ep_2_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_3_le -- aw_arb_slv_ep_3_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_4_le -- aw_arb_slv_ep_4_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_5_le -- aw_arb_slv_ep_5_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_6_le -- aw_arb_slv_ep_6_ri : arb_slv_ch<aw_pack_t>;
    chan aw_arb_slv_ep_7_le -- aw_arb_slv_ep_7_ri : arb_slv_ch<aw_pack_t>;

    chan aw_arb_mst_ch_le -- aw_arb_mst_ch_ri : arb_mst_ch<aw_pack_t, 3>;
    
    chan ar_arb_slv_ep_0_le -- ar_arb_slv_ep_0_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_1_le -- ar_arb_slv_ep_1_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_2_le -- ar_arb_slv_ep_2_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_3_le -- ar_arb_slv_ep_3_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_4_le -- ar_arb_slv_ep_4_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_5_le -- ar_arb_slv_ep_5_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_6_le -- ar_arb_slv_ep_6_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_slv_ep_7_le -- ar_arb_slv_ep_7_ri : arb_slv_ch<ar_pack_t>;
    chan ar_arb_mst_ch_le -- ar_arb_mst_ch_ri : arb_mst_ch<ar_pack_t, 3>;
    
    chan aw_flush_ep_le -- aw_flush_ep_ri : flush_ch;
    chan ar_flush_ep_le -- ar_flush_ep_ri : flush_ch;

    // Spawn component instances
    spawn fifo<select_t, MaxTrans, 3>(w_fifo_le);
    spawn fifo<select_t, MaxTrans, 3>(b_fifo_le);
    spawn fifo<select_t, MaxTrans, 3>(r_fifo_le);
    
    spawn spill_reg< 1, aw_sel_pack_t, AW_BYPASS >(aw_sr_ri);
    spawn spill_reg< 2, w_pack_t, W_BYPASS >(w_sr_ri);
    spawn spill_reg< 3, b_pack_t, B_BYPASS >(b_sr_ri);
    spawn spill_reg< 4, ar_sel_pack_t, AR_BYPASS >(ar_sr_ri);
    spawn spill_reg< 5, r_pack_t, R_BYPASS >(r_sr_ri);
    
    // Round-robin arbiters for AW and AR channels
    spawn rr_arbiter(
        aw_arb_slv_ep_0_le, aw_arb_slv_ep_1_le, aw_arb_slv_ep_2_le, aw_arb_slv_ep_3_le,
        aw_arb_slv_ep_4_le, aw_arb_slv_ep_5_le, aw_arb_slv_ep_6_le, aw_arb_slv_ep_7_le,
        aw_arb_mst_ch_ri, aw_flush_ep_le
    );
    
    spawn rr_arbiter(
        ar_arb_slv_ep_0_le, ar_arb_slv_ep_1_le, ar_arb_slv_ep_2_le, ar_arb_slv_ep_3_le,
        ar_arb_slv_ep_4_le, ar_arb_slv_ep_5_le, ar_arb_slv_ep_6_le, ar_arb_slv_ep_7_le,
        ar_arb_mst_ch_ri, ar_flush_ep_le
    );

//---------------------------------------------Write Transaction------------------------------------------------------------
    loop{
        send aw_flush_ep_ri.flush(1'd0) >>
        send ar_flush_ep_ri.flush(1'd0) >>
        cycle 1
    }
    // AW Channel Arbitration - collect requests from all slave ports and send based on priority
    loop {
    
        let aw_default = aw_pack_t::{
            addr = <(32'h0)::A>;
            prot = <(3'b0)::prot_t>
        } >>
        send aw_arb_slv_ep_0_ri.req((ready slv_ep_0.aw_req))>>
        send aw_arb_slv_ep_1_ri.req((ready slv_ep_1.aw_req))>>
        send aw_arb_slv_ep_2_ri.req((ready slv_ep_2.aw_req))>>
        send aw_arb_slv_ep_3_ri.req((ready slv_ep_3.aw_req))>>
        send aw_arb_slv_ep_4_ri.req((ready slv_ep_4.aw_req))>>
        send aw_arb_slv_ep_5_ri.req((ready slv_ep_5.aw_req))>>
        send aw_arb_slv_ep_6_ri.req((ready slv_ep_6.aw_req))>>
        send aw_arb_slv_ep_7_ri.req((ready slv_ep_7.aw_req))>>

        let gnt_0 = recv aw_arb_slv_ep_0_ri.gnt >>
        let gnt_1 = recv aw_arb_slv_ep_1_ri.gnt >>
        let gnt_2 = recv aw_arb_slv_ep_2_ri.gnt >>
        let gnt_3 = recv aw_arb_slv_ep_3_ri.gnt >>
        let gnt_4 = recv aw_arb_slv_ep_4_ri.gnt >>
        let gnt_5 = recv aw_arb_slv_ep_5_ri.gnt >>
        let gnt_6 = recv aw_arb_slv_ep_6_ri.gnt >>
        let gnt_7 = recv aw_arb_slv_ep_7_ri.gnt >>
        let rdy = recv aw_sr_le.rdy >>
        send aw_arb_mst_ch_le.gnt(rdy) >>
        if(gnt_0){
                try aw_req = recv slv_ep_0.aw_req {
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd0)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_1) {
                try aw_req = recv slv_ep_1.aw_req {
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd1)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_2) {
                try aw_req = recv slv_ep_2.aw_req {
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd2)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_3) {
                try aw_req = recv slv_ep_3.aw_req {
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd3)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_4) {
                try aw_req = recv slv_ep_4.aw_req{
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd4)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_5) {
                try aw_req = recv slv_ep_5.aw_req{
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd5)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_6) {
                try aw_req = recv slv_ep_6.aw_req{
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd6)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        }
        else if(gnt_7) {
                try aw_req = recv slv_ep_7.aw_req{
                    let aw_req_pack = aw_sel_pack_t::{
                        aw_pack = aw_req;
                        select = <(3'd7)::select_t>
                    };
                    send aw_sr_le.req(aw_req_pack)
                }
        } >>

        cycle 1
    }
    loop{ //Unused arbitration values
        let _ = recv aw_arb_mst_ch_le.req >>
        let idx_o  = recv aw_arb_mst_ch_le.idx_o >>
        cycle 1
    }
    loop{
        //Collect AW req and serve mst_ep
        let f = recv w_fifo_ep.full >>
        if (f == 1'b1) {
            cycle 1
        } else {
            let aw_req = recv aw_sr_le.res >>
            send mst_ep.mst_aw_req(aw_req.aw_pack) >>
            send w_fifo_ep.push(aw_req.select) >>
            send aw_sr_le.spill(1'd1) >>
            cycle 1
        }
    }

    loop{
        let rdy = recv  w_sr_le.rdy >>
        let w_fifo_empty = recv w_fifo_ep.empty >>
        let b_fifo_full = recv b_fifo_ep.full >>
        if(rdy == 1'd1 && w_fifo_empty == 1'd0 && b_fifo_full == 1'd0){
            send w_fifo_ep.pop(1'd1) >>
            let sel = recv w_fifo_ep.data_o  >>
            send b_fifo_ep.push(sel) >>
            match sel {
                3'd0 =>{
                    let w_req = recv slv_ep_0.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd1 =>{
                    let w_req = recv slv_ep_1.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd2 =>{
                    let w_req = recv slv_ep_2.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd3 =>{
                    let w_req = recv slv_ep_3.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd4 =>{
                    let w_req = recv slv_ep_4.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd5 =>{
                    let w_req = recv slv_ep_5.w_req >>
                    send w_sr_le.req(w_req)
                },
                3'd6 =>{
                    let w_req = recv slv_ep_6.w_req >>
                    send w_sr_le.req(w_req)
                },
                _ =>{
                    let w_req = recv slv_ep_7.w_req >>
                    send w_sr_le.req(w_req)
                }
            } >>
            cycle 1
        }
        else {
            cycle 1
        }
    }
    loop{
        let w_req = recv w_sr_le.res >>
        send mst_ep.mst_w_req(w_req) >>
        send w_sr_le.spill(1'd1) >>
        cycle 1
    }
    loop{
        let b_fifo_empty = recv b_fifo_ep.empty >>
        if ((b_fifo_empty == 1'b0)){
            send b_fifo_ep.pop(1'd1) >>
            let sel = recv b_fifo_ep.data_o  >>
            match sel{
                3'd0 =>{
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_0.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                3'd1 => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_1.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                3'd2 =>{
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_2.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                3'd3 => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_3.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                3'd4 => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_4.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)

                },
                3'd5 => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_5.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                3'd6 => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_6.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                },
                _ => {
                    let b_resp = recv b_sr_le.res >>
                    send slv_ep_7.b_resp(b_resp) >>
                    send b_sr_le.spill(1'd1)
                }
                
            } >>
            cycle 1
            
        }
        else{
            cycle 1
        }
    }


    loop{
        let rdy = recv b_sr_le.rdy >>
        if (rdy == 1'd1){
            let b_resp = recv mst_ep.mst_b_resp >>
            send b_sr_le.req(b_resp)
        }
        else{
            ()
        } >>
        cycle 1
        
    }

//---------------------------------------------Read Transaction------------------------------------------------------------

    // AR Channel Arbitration - collect requests from all slave ports and send based on priority
    loop {
        let ar_default = ar_pack_t::{
            addr = <(32'h0)::A>;
            prot = <(3'b0)::prot_t>
        } >>
        send ar_arb_slv_ep_0_ri.req((ready slv_ep_0.ar_req))>>
        send ar_arb_slv_ep_1_ri.req((ready slv_ep_1.ar_req))>>
        send ar_arb_slv_ep_2_ri.req((ready slv_ep_2.ar_req))>>
        send ar_arb_slv_ep_3_ri.req((ready slv_ep_3.ar_req))>>
        send ar_arb_slv_ep_4_ri.req((ready slv_ep_4.ar_req))>>
        send ar_arb_slv_ep_5_ri.req((ready slv_ep_5.ar_req))>>
        send ar_arb_slv_ep_6_ri.req((ready slv_ep_6.ar_req))>>
        send ar_arb_slv_ep_7_ri.req((ready slv_ep_7.ar_req))>>

        let gnt_0 = recv ar_arb_slv_ep_0_ri.gnt >>
        let gnt_1 = recv ar_arb_slv_ep_1_ri.gnt >>
        let gnt_2 = recv ar_arb_slv_ep_2_ri.gnt >>
        let gnt_3 = recv ar_arb_slv_ep_3_ri.gnt >>
        let gnt_4 = recv ar_arb_slv_ep_4_ri.gnt >>
        let gnt_5 = recv ar_arb_slv_ep_5_ri.gnt >>
        let gnt_6 = recv ar_arb_slv_ep_6_ri.gnt >>
        let gnt_7 = recv ar_arb_slv_ep_7_ri.gnt >>
        let rdy = recv ar_sr_le.rdy >>
        send ar_arb_mst_ch_le.gnt(rdy) >>
        if(gnt_0) {
                try ar_req = recv slv_ep_0.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd0)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_1) {
                try ar_req = recv slv_ep_1.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd1)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_2) {
                try ar_req = recv slv_ep_2.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd2)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_3) {
                try ar_req = recv slv_ep_3.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd3)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_4) {
                try ar_req = recv slv_ep_4.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd4)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_5) {
                try ar_req = recv slv_ep_5.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd5)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_6) {
                try ar_req = recv slv_ep_6.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd6)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        else if(gnt_7) {
                try ar_req = recv slv_ep_7.ar_req {
                    let ar_req_pack = ar_sel_pack_t::{
                        ar_pack = ar_req;
                        select = <(3'd7)::select_t>
                    };
                    send ar_sr_le.req(ar_req_pack)
                }
        }
        >>

        cycle 1
    }
    
    loop{ //Unused arbitration values for AR
        let _ = recv ar_arb_mst_ch_le.req >>
        let idx_o = recv ar_arb_mst_ch_le.idx_o >>
        cycle 1
    }
    
    loop{
        //Collect AR req and serve mst_ep
        let f = recv r_fifo_ep.full >>
        if (f == 1'b1) {
            cycle 1
        } else {
            let ar_req = recv ar_sr_le.res >>
            send mst_ep.mst_ar_req(ar_req.ar_pack) >>
            send r_fifo_ep.push(ar_req.select) >>
            send ar_sr_le.spill(1'd1) >>
            cycle 1
        }
    }

    loop{
        let r_fifo_empty = recv r_fifo_ep.empty >>
        if (r_fifo_empty == 1'b0) {
            send r_fifo_ep.pop(1'd1) >>
            let sel = recv r_fifo_ep.data_o >>
            match sel {
                3'd0 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_0.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd1 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_1.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd2 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_2.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd3 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_3.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd4 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_4.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd5 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_5.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                3'd6 => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_6.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                },
                _ => {
                    let r_resp = recv r_sr_le.res >>
                    send slv_ep_7.r_resp(r_resp) >>
                    send r_sr_le.spill(1'd1)
                }
            } >>
            cycle 1
        }
        else {
            cycle 1
        }
    }

    loop{
        let rdy = recv r_sr_le.rdy >>
        if (rdy == 1'd1) {
            let r_resp = recv mst_ep.mst_r_resp >>
            send r_sr_le.req(r_resp)
        }
        else {
            ()
        } >>
        cycle 1
    }

// ------------------------------------End of the axi lite mux------------------------------------------------
}

import "common_cells.anvilh"

proc axi_lite_mux<
                aw_pack_t : type,
                w_pack_t : type,
                b_pack_t : type,
                ar_pack_t : type,
                r_pack_t : type,
                AW_BYPASS : int,
                W_BYPASS : int,
                B_BYPASS : int,
                AR_BYPASS : int,
                R_BYPASS : int,
                NoSlvPorts : int,
                MaxTrans : int
            >
(
    // Multiple slave ports (input from masters)
    slv_ep_0 : left slave_mux_ch,
    slv_ep_1 : left slave_mux_ch,
    slv_ep_2 : left slave_mux_ch,
    slv_ep_3 : left slave_mux_ch,
    slv_ep_4 : left slave_mux_ch,
    slv_ep_5 : left slave_mux_ch,
    slv_ep_6 : left slave_mux_ch,
    slv_ep_7 : left slave_mux_ch,
    // Single master port (output to slave)
    mst_ep : left master_ch
)
// AXI Lite Multiplexer: Multiple slave ports -> One master port
{
    // Create default values for data types
    
    
    chan aw_sr_le -- aw_sr_ri : spill_ch< aw_sel_pack_t >;
    chan w_sr_le -- w_sr_ri : spill_ch< w_pack_t >;
    chan b_sr_le -- b_sr_ri : spill_ch< b_pack_t >;
    chan ar_sr_le -- ar_sr_ri : spill_ch< ar_sel_pack_t >;
    chan r_sr_le -- r_sr_ri : spill_ch< r_pack_t >;
    
    
    chan w_fifo_le -- w_fifo_ep : fifo_ch<select_t>;
    chan b_fifo_le -- b_fifo_ep : fifo_ch<select_t>;
    chan r_fifo_le -- r_fifo_ep : fifo_ch<select_t>;
    
    // Round-robin arbiter channels for AW and AR
    chan aw_arb_slv_ep_0_le -- aw_arb_slv_ep_0_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_1_le -- aw_arb_slv_ep_1_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_2_le -- aw_arb_slv_ep_2_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_3_le -- aw_arb_slv_ep_3_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_4_le -- aw_arb_slv_ep_4_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_5_le -- aw_arb_slv_ep_5_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_6_le -- aw_arb_slv_ep_6_ri : arb_slv_ch<logic>;
    chan aw_arb_slv_ep_7_le -- aw_arb_slv_ep_7_ri : arb_slv_ch<logic>;

    chan aw_arb_mst_ch_le -- aw_arb_mst_ch_ri : arb_mst_ch<logic, 3>;
    
    chan ar_arb_slv_ep_0_le -- ar_arb_slv_ep_0_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_1_le -- ar_arb_slv_ep_1_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_2_le -- ar_arb_slv_ep_2_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_3_le -- ar_arb_slv_ep_3_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_4_le -- ar_arb_slv_ep_4_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_5_le -- ar_arb_slv_ep_5_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_6_le -- ar_arb_slv_ep_6_ri : arb_slv_ch<logic>;
    chan ar_arb_slv_ep_7_le -- ar_arb_slv_ep_7_ri : arb_slv_ch<logic>;
    chan ar_arb_mst_ch_le -- ar_arb_mst_ch_ri : arb_mst_ch<logic, 3>;
    
    chan aw_flush_ep_le -- aw_flush_ep_ri : flush_ch;
    chan ar_flush_ep_le -- ar_flush_ep_ri : flush_ch;

    // Spawn component instances
    spawn fifo<select_t, MaxTrans, 3>(w_fifo_le);
    spawn fifo<select_t, MaxTrans, 3>(b_fifo_le);
    spawn fifo<select_t, MaxTrans, 3>(r_fifo_le);
    
    spawn spill_reg< 1, aw_sel_pack_t, AW_BYPASS >(aw_sr_ri);
    spawn spill_reg< 2, w_pack_t, W_BYPASS >(w_sr_ri);
    spawn spill_reg< 3, b_pack_t, B_BYPASS >(b_sr_ri);
    spawn spill_reg< 4, ar_sel_pack_t, AR_BYPASS >(ar_sr_ri);
    spawn spill_reg< 5, r_pack_t, R_BYPASS >(r_sr_ri);
    
    // Round-robin arbiters for AW and AR channels
    spawn rr_arbiter<1,logic>(
        aw_arb_slv_ep_0_le, aw_arb_slv_ep_1_le, aw_arb_slv_ep_2_le, aw_arb_slv_ep_3_le,
        aw_arb_slv_ep_4_le, aw_arb_slv_ep_5_le, aw_arb_slv_ep_6_le, aw_arb_slv_ep_7_le,
        aw_arb_mst_ch_ri, aw_flush_ep_le
    );
    
    spawn rr_arbiter<0,logic>(
        ar_arb_slv_ep_0_le, ar_arb_slv_ep_1_le, ar_arb_slv_ep_2_le, ar_arb_slv_ep_3_le,
        ar_arb_slv_ep_4_le, ar_arb_slv_ep_5_le, ar_arb_slv_ep_6_le, ar_arb_slv_ep_7_le,
        ar_arb_mst_ch_ri, ar_flush_ep_le
    );
//---------------------------------------------Write Transaction------------------------------------------------------------
    loop{
        send aw_flush_ep_ri.flush(1'd0) >>
        send ar_flush_ep_ri.flush(1'd0) >>
        cycle 1
    }
    // AW Channel Arbitration - collect requests from all slave ports and send based on priority
    loop {
    {
    
        let aw_default = aw_pack_t::{
            addr = <(32'h0)::A>;
            prot = <(3'b0)::prot_t>
        } >>
        send aw_arb_slv_ep_0_ri.req((ready slv_ep_0.aw_req))>>
        send aw_arb_slv_ep_1_ri.req((ready slv_ep_1.aw_req))>>
        send aw_arb_slv_ep_2_ri.req((ready slv_ep_2.aw_req))>>
        send aw_arb_slv_ep_3_ri.req((ready slv_ep_3.aw_req))>>
        send aw_arb_slv_ep_4_ri.req((ready slv_ep_4.aw_req))>>
        send aw_arb_slv_ep_5_ri.req((ready slv_ep_5.aw_req))>>
        send aw_arb_slv_ep_6_ri.req((ready slv_ep_6.aw_req))>>
        send aw_arb_slv_ep_7_ri.req((ready slv_ep_7.aw_req))>>


        send aw_arb_slv_ep_0_ri.data(1'd0) >>
        send aw_arb_slv_ep_1_ri.data(1'd0) >>
        send aw_arb_slv_ep_2_ri.data(1'd0) >>
        send aw_arb_slv_ep_3_ri.data(1'd0) >>
        send aw_arb_slv_ep_4_ri.data(1'd0) >>
        send aw_arb_slv_ep_5_ri.data(1'd0) >>
        send aw_arb_slv_ep_6_ri.data(1'd0) >>
        send aw_arb_slv_ep_7_ri.data(1'd0) >>


        let gnt_0 = recv aw_arb_slv_ep_0_ri.gnt >>
        let gnt_1 = recv aw_arb_slv_ep_1_ri.gnt >>
        let gnt_2 = recv aw_arb_slv_ep_2_ri.gnt >>
        let gnt_3 = recv aw_arb_slv_ep_3_ri.gnt >>
        let gnt_4 = recv aw_arb_slv_ep_4_ri.gnt >>
        let gnt_5 = recv aw_arb_slv_ep_5_ri.gnt >>
        let gnt_6 = recv aw_arb_slv_ep_6_ri.gnt >>
        let gnt_7 = recv aw_arb_slv_ep_7_ri.gnt >>
        
        let rdy = recv aw_sr_le.rdy >>
        let aw_null = 36'd0 >>
        send aw_arb_mst_ch_le.gnt(rdy) >>
        

        let awp = if(gnt_0){
                try aw_req = recv slv_ep_0.aw_req {
                    #flat{aw_req, 3'd0,1'd1}
                }
                else {
                    aw_null
                }
        }
        else if(gnt_1) {
                try aw_req = recv slv_ep_1.aw_req {
                    #flat{aw_req, 3'd1,1'd1}
                }
                else{
                    aw_null 
                }
        }
        else if(gnt_2) {
                try aw_req = recv slv_ep_2.aw_req {
                    #flat{aw_req, 3'd2,1'd1}
                }
                else{
                    aw_null
                }
        
        }
        else if(gnt_3) {
                try aw_req = recv slv_ep_3.aw_req {
                    #flat{aw_req, 3'd3,1'd1}
                }
                else{
                    aw_null
                }
        }
        else if(gnt_4) {
                try aw_req = recv slv_ep_4.aw_req{
                    #flat{aw_req, 3'd4,1'd1}
                }
                else{
                    aw_null
                }
        }
        else if(gnt_5) {
                try aw_req = recv slv_ep_5.aw_req{
                    #flat{aw_req, 3'd5,1'd1}
                }
                else{
                    aw_null
                }
        }
        else if(gnt_6) {
                try aw_req = recv slv_ep_6.aw_req{
                    #flat{aw_req, 3'd6,1'd1}
                }
                else{
                    aw_null
                }
        }
        else if(gnt_6) {
                try aw_req = recv slv_ep_6.aw_req{
                    #flat{aw_req, 3'd6,1'd1}
                }
                else{
                    aw_null
                }
        }
        else if(gnt_7) {
                try aw_req = recv slv_ep_7.aw_req{
                    #flat{aw_req, 3'd7,1'd1}
                }
                else{

                    aw_null
                }
        } else{
            aw_null
            
        } >>
        if (awp[0]){
            let aw_p = (<(awp[1+:35])::aw_sel_pack_t>) >>
            send w_fifo_ep.push(awp[1+:3]) >>
            send aw_sr_le.req(aw_p)
        } 
    };
    // loop{ //Unused arbitration values
    //     try _ = recv aw_arb_mst_ch_le.req {
    //         ()
    //     }
    //     try _  = recv aw_arb_mst_ch_le.idx_o {
    //         ()
    //     } >>
    //     cycle 1
    // }
    {
        //Collect AW req and serve mst_ep
        let f = recv w_fifo_ep.full >>
        if (f == 1'b0){
        let null = 4'd0;
        let tc = try aw_req = recv aw_sr_le.res {
                try send mst_ep.mst_aw_req(aw_req.aw_pack){
                    #flat{aw_req.select,1'd1}
                }
                else{
                    null
                }
            }
        else{
                null
        } >>
        if (tc[0] == 1'd1){
                // let sel = (<(tc[1+:3])::select_t>)  >>
                send aw_sr_le.spill(1'd1)
        }
      }

    };

    {
        let rdy = recv  w_sr_le.rdy >>
        let w_fifo_empty = recv w_fifo_ep.empty >>
        let b_fifo_full = recv b_fifo_ep.full >>
        if(rdy == 1'd1 && w_fifo_empty == 1'd0 && b_fifo_full == 1'd0){
            // send w_fifo_ep.pop(1'd1) >>
            let sel = recv w_fifo_ep.data_o  >>
            send b_fifo_ep.push(sel) >>
            let null = 36'd0 >>

            let tc = match sel {
                3'd0 =>{
                    try w_req = recv slv_ep_0.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd1 =>{
                    try w_req = recv slv_ep_1.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd2 =>{
                    try w_req = recv slv_ep_2.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd3 =>{
                    try w_req = recv slv_ep_3.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd4 =>{
                    try w_req = recv slv_ep_4.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd5 =>{
                    try w_req = recv slv_ep_5.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                3'd6 =>{
                    try w_req = recv slv_ep_6.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                },
                _ =>{
                    try w_req = recv slv_ep_7.w_req{
                        #flat{w_req,1'd1}
                    }
                    else{
                        null
                    }
                }
            } >>
            if(tc[0]){
                // dprint "[Cycle %d] Sending W req %h" (*cyc, tc[1+:35]) >>
                send w_sr_le.req(tc[1+:35]) >>
                send w_fifo_ep.pop(1'd1)
            }

        }
        // else{
        //     // dprint "[Cycle %d] Not ready for w trans %d | %d | %d" (*cyc, rdy, w_fifo_empty, b_fifo_full)
        // }
    };
    {
        let tc = try w_req = recv w_sr_le.res{
            try send mst_ep.mst_w_req(w_req){
                1'd1
            }
            else{
                1'd0
            }
        }
        else{
            1'd0
        } >>
        if(tc){
            send w_sr_le.spill(1'd1)
        }
        
    };
    {
        let b_fifo_empty = recv b_fifo_ep.empty >>
        if ((b_fifo_empty == 1'b0)){
            // send b_fifo_ep.pop(1'd1) >>
            let sel = recv b_fifo_ep.data_o  >>
            let tc = match sel{
                3'd0 =>{
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_0.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd1 => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_1.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd2 =>{
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_2.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd3 => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_3.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                    
                },
                3'd4 => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_4.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }

                },
                3'd5 => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_5.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd6 => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_6.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                _ => {
                    try b_resp = recv b_sr_le.res {
                        try send slv_ep_7.b_resp(b_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                }
                
            } >>
            if(tc){
                send b_sr_le.spill(1'd1) >>
                send b_fifo_ep.pop(1'd1)
            }

        }
       
    };


    {
        let rdy = recv b_sr_le.rdy >>
        let null = 3'd0 >>
        if (rdy == 1'd1){
            let tc = try b_resp = recv mst_ep.mst_b_resp {
                #flat{b_resp, 1'd1}
            }
            else{
                null
            } >>
            if(tc[0]){
                send b_sr_le.req(tc[1+:2])
            }
        } 
        
    };

//---------------------------------------------Read Transaction------------------------------------------------------------

    // AR Channel Arbitration - collect requests from all slave ports and send based on priority
    {
        let ar_default = ar_pack_t::{
            addr = <(32'h0)::A>;
            prot = <(3'b0)::prot_t>
        } >>
        send ar_arb_slv_ep_0_ri.req((ready slv_ep_0.ar_req))>>
        send ar_arb_slv_ep_1_ri.req((ready slv_ep_1.ar_req))>>
        send ar_arb_slv_ep_2_ri.req((ready slv_ep_2.ar_req))>>
        send ar_arb_slv_ep_3_ri.req((ready slv_ep_3.ar_req))>>
        send ar_arb_slv_ep_4_ri.req((ready slv_ep_4.ar_req))>>
        send ar_arb_slv_ep_5_ri.req((ready slv_ep_5.ar_req))>>
        send ar_arb_slv_ep_6_ri.req((ready slv_ep_6.ar_req))>>
        send ar_arb_slv_ep_7_ri.req((ready slv_ep_7.ar_req))>>

        send ar_arb_slv_ep_0_ri.data(1'd0) >>
        send ar_arb_slv_ep_1_ri.data(1'd0) >>
        send ar_arb_slv_ep_2_ri.data(1'd0) >>
        send ar_arb_slv_ep_3_ri.data(1'd0) >>
        send ar_arb_slv_ep_4_ri.data(1'd0) >>
        send ar_arb_slv_ep_5_ri.data(1'd0) >>
        send ar_arb_slv_ep_6_ri.data(1'd0) >>
        send ar_arb_slv_ep_7_ri.data(1'd0) >>

        let gnt_0 = recv ar_arb_slv_ep_0_ri.gnt >>
        let gnt_1 = recv ar_arb_slv_ep_1_ri.gnt >>
        let gnt_2 = recv ar_arb_slv_ep_2_ri.gnt >>
        let gnt_3 = recv ar_arb_slv_ep_3_ri.gnt >>
        let gnt_4 = recv ar_arb_slv_ep_4_ri.gnt >>
        let gnt_5 = recv ar_arb_slv_ep_5_ri.gnt >>
        let gnt_6 = recv ar_arb_slv_ep_6_ri.gnt >>
        let gnt_7 = recv ar_arb_slv_ep_7_ri.gnt >>
        
        let rdy = recv ar_sr_le.rdy >>
        let ar_null = 36'd0 >>
        send ar_arb_mst_ch_le.gnt(rdy) >>
        
        let arp = if(gnt_0){
                try ar_req = recv slv_ep_0.ar_req {
                    #flat{ar_req, 3'd0,1'd1}
                }
                else {
                    ar_null
                }
        }
        else if(gnt_1) {
                try ar_req = recv slv_ep_1.ar_req {
                    #flat{ar_req, 3'd1,1'd1}
                }
                else{
                    ar_null 
                }
        }
        else if(gnt_2) {
                try ar_req = recv slv_ep_2.ar_req {
                    #flat{ar_req, 3'd2,1'd1}
                }
                else{
                    ar_null
                }
        }
        else if(gnt_3) {
                try ar_req = recv slv_ep_3.ar_req {
                    #flat{ar_req, 3'd3,1'd1}
                }
                else{
                    ar_null
                }
        }
        else if(gnt_4) {
                try ar_req = recv slv_ep_4.ar_req{
                    #flat{ar_req, 3'd4,1'd1}
                }
                else{
                    ar_null
                }
        }
        else if(gnt_5) {
                try ar_req = recv slv_ep_5.ar_req{
                    #flat{ar_req, 3'd5,1'd1}
                }
                else{
                    ar_null
                }
        }
        else if(gnt_6) {
                try ar_req = recv slv_ep_6.ar_req{
                    #flat{ar_req, 3'd6,1'd1}
                }
                else{
                    ar_null
                }
        }
        else if(gnt_7) {
                try ar_req = recv slv_ep_7.ar_req{
                    #flat{ar_req, 3'd7,1'd1}
                }
                else{
                    ar_null
                }
        } else{
            ar_null
        } >>
        if (arp[0]){
            let ar_p = (<(arp[1+:35])::ar_sel_pack_t>) >>
            send ar_sr_le.req(ar_p)
        } 
    };
    
    // loop{ //Unused arbitration values for AR
    //     try _ = recv ar_arb_mst_ch_le.req {
    //         ()
    //     }
    //     try _  = recv ar_arb_mst_ch_le.idx_o {
    //         ()
    //     } >>
    //     cycle 1
    // }
    
    {
        //Collect AR req and serve mst_ep
        let f = recv r_fifo_ep.full >>
        if (f == 1'b0){
        let null = 4'd0;
        let tc = try ar_req = recv ar_sr_le.res {
                try send mst_ep.mst_ar_req(ar_req.ar_pack){
                    #flat{ar_req.select,1'd1}
                }
                else{
                    null
                }
            }
        else{
                null
        } >>
        if (tc[0] == 1'd1){
                send r_fifo_ep.push(tc[1+:3]) >>
                send ar_sr_le.spill(1'd1)
        } 
            
        } 
    };

    {
        let r_fifo_empty = recv r_fifo_ep.empty >>
        if ((r_fifo_empty == 1'b0)){
            let sel = recv r_fifo_ep.data_o  >>
            let tc = match sel{
                3'd0 =>{
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_0.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd1 => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_1.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd2 =>{
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_2.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd3 => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_3.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd4 => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_4.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd5 => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_5.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                3'd6 => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_6.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                },
                _ => {
                    try r_resp = recv r_sr_le.res {
                        try send slv_ep_7.r_resp(r_resp) {
                            1'd1
                        }
                        else{
                            1'd0
                        }
                    }
                    else{
                        1'd0
                    }
                }
            } >>
            if(tc){
                send r_sr_le.spill(1'd1) >>
                send r_fifo_ep.pop(1'd1)
            }
        }
        
    };

    {
        let rdy = recv r_sr_le.rdy >>
        let null = 35'd0 >>
        if (rdy == 1'd1) {
           let tc = try r_resp = recv mst_ep.mst_r_resp {
                #flat{r_resp,1'd1}
            }
            else{
                null
            } >>
            if(tc[0]){
                send r_sr_le.req(tc[1+:34])
            }
        } 
    } >>
    cycle 1
}

// ------------------------------------End of the axi lite mux------------------------------------------------
}
